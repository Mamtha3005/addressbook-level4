# A0139257X
###### \java\seedu\taskell\logic\commands\AddCommand.java
``` java
/**
 * Adds a task to the task manager.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to the task manager. "
            + "Parameters: DESCRIPTION by/on[DATE] from[START_TIME] to[END_TIME] [p/PRIORITY] [#TAG]...\n"
            + "Example: " + COMMAND_WORD
            + " go for meeting on 1-1-2100 from 12.30AM to 12.45AM p/3 #work";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager";

    private final Task toAdd;

    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */

    public AddCommand(String description, String taskType, String startDate, String endDate, String startTime, String endTime, String taskPriority, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        
        switch (taskType) {
        case Task.FLOATING_TASK: 
            this.toAdd = new FloatingTask(description, taskPriority, TaskStatus.INCOMPLETE, new UniqueTagList(tagSet));
            break;
        case Task.EVENT_TASK:
            this.toAdd = new EventTask(description, startDate, endDate, startTime, endTime, taskPriority, TaskStatus.INCOMPLETE, new UniqueTagList(tagSet));
            break;
        default:
            toAdd = null;
        }
    }

```
###### \java\seedu\taskell\logic\parser\Parser.java
``` java

    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args) {
        if (args.isEmpty()) {
            UndoCommand.deletePreviousCommand();
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }

        ArrayList<String> argsList = tokenizeArguments(args);
        Queue<String> initialQueue = initialiseArgQueue(argsList);
        Queue<String> descriptionQueue = new LinkedList<String>();
        Queue<String> byQueue = new LinkedList<String>();
        Queue<String> onQueue = new LinkedList<String>();
        Queue<String> atQueue = new LinkedList<String>();
        Queue<String> fromQueue = new LinkedList<String>();
        Queue<String> toQueue = new LinkedList<String>();

        String description = "";
        String startDate = TaskDate.DEFAULT_DATE;
        String endDate = startDate;
        String startTime = TaskTime.DEFAULT_START_TIME;
        String endTime = TaskTime.DEFAULT_END_TIME;
        String token = "";
        String taskPriority = TaskPriority.DEFAULT_PRIORITY;
        String tagString = "";

        int priorityCount = 0;

        boolean hasStartDate = false;
        boolean hasEndDate = false;
        boolean hasStartTime = false;
        boolean hasEndTime = false;

        while (!initialQueue.isEmpty()) {
            token = initialQueue.poll().trim();
            String tempToken = "";

            if (!token.equals(BY) && !token.equals(ON) && !token.equals(AT) && !token.equals(FROM) && !token.equals(TO)
                    && !TaskDate.isValidDate(token) && !TaskTime.isValidTime(token) && !token.startsWith(Tag.PREFIX)
                    && !token.startsWith(TaskPriority.PREFIX)) {
                tempToken = flushQueue(byQueue, onQueue, atQueue, fromQueue, toQueue);
                if (!tempToken.isEmpty()) {
                    descriptionQueue.offer(tempToken);
                }
                descriptionQueue.offer(token);
                continue;
            } else if (token.equals(BY)) {
                tempToken = flushQueue(byQueue, onQueue, atQueue, fromQueue, toQueue);
                if (!tempToken.isEmpty()) {
                    descriptionQueue.offer(tempToken);
                }
                byQueue.offer(token);
                continue;
            } else if (token.equals(ON)) {
                tempToken = flushQueue(byQueue, onQueue, atQueue, fromQueue, toQueue);
                if (!tempToken.isEmpty()) {
                    descriptionQueue.offer(tempToken);
                }
                onQueue.offer(token);
                continue;
            } else if (token.equals(AT)) {
                tempToken = flushQueue(byQueue, onQueue, atQueue, fromQueue, toQueue);
                if (!tempToken.isEmpty()) {
                    descriptionQueue.offer(tempToken);
                }
                atQueue.offer(token);
                continue;
            } else if (token.equals(FROM)) {
                tempToken = flushQueue(byQueue, onQueue, atQueue, fromQueue, toQueue);
                if (!tempToken.isEmpty()) {
                    descriptionQueue.offer(tempToken);
                }
                fromQueue.offer(token);
                continue;
            } else if (token.equals(TO)) {
                tempToken = flushQueue(byQueue, onQueue, atQueue, fromQueue, toQueue);
                if (!tempToken.isEmpty()) {
                    descriptionQueue.offer(tempToken);
                }
                toQueue.offer(token);
                continue;
            } else if (token.startsWith(Tag.PREFIX)) {
                tempToken = flushQueue(byQueue, onQueue, atQueue, fromQueue, toQueue);
                if (!tempToken.isEmpty()) {
                    descriptionQueue.offer(tempToken);
                }
                tagString += " " + token;
                continue;
            } else if (token.startsWith(TaskPriority.PREFIX)) {
                tempToken = flushQueue(byQueue, onQueue, atQueue, fromQueue, toQueue);
                if (!tempToken.isEmpty()) {
                    descriptionQueue.offer(tempToken);
                }
                if (priorityCount > 0) {
                    return new IncorrectCommand(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
                } else {
                    taskPriority = token.substring(token.indexOf(TaskPriority.PREFIX) + 2);
                    priorityCount++;
                }
                continue;
            } else if (TaskDate.isValidDate(token)) {
                if (byQueue.isEmpty() && onQueue.isEmpty() && atQueue.isEmpty() && fromQueue.isEmpty()
                        && toQueue.isEmpty()) {
                    descriptionQueue.offer(token);
                } else if (!onQueue.isEmpty()) {
                    if (!hasStartDate) {
                        onQueue.poll();
                        startDate = token;
                        hasStartDate = true;
                    } else {
                        descriptionQueue.offer(onQueue.poll());
                        descriptionQueue.offer(token);
                    }
                } else if (!byQueue.isEmpty()) {
                    if (!hasEndDate) {
                        byQueue.poll();
                        endDate = token;
                        hasEndDate = true;
                    } else {
                        descriptionQueue.offer(byQueue.poll());
                        descriptionQueue.offer(token);
                    }
                } else if (!atQueue.isEmpty()) {
                    descriptionQueue.offer(atQueue.poll());
                    descriptionQueue.offer(token);
                } else if (!fromQueue.isEmpty()) {
                    if (!hasStartDate) {
                        fromQueue.poll();
                        startDate = token;
                        hasStartDate = true;
                    } else {
                        descriptionQueue.offer(fromQueue.poll());
                        descriptionQueue.offer(token);
                    }
                } else if (!toQueue.isEmpty()) {
                    if (!hasEndDate) {
                        toQueue.poll();
                        endDate = token;
                        hasEndDate = true;
                    } else {
                        descriptionQueue.offer(toQueue.poll());
                        descriptionQueue.offer(token);
                    }
                }
            } else if (TaskTime.isValidTime(token)) {
                if (byQueue.isEmpty() && onQueue.isEmpty() && atQueue.isEmpty() && fromQueue.isEmpty()
                        && toQueue.isEmpty()) {
                    descriptionQueue.offer(token);
                } else if (!byQueue.isEmpty()) {
                    if (!hasEndTime) {
                        byQueue.poll();
                        endTime = token;
                        hasEndTime = true;
                    } else {
                        descriptionQueue.offer(byQueue.poll());
                        descriptionQueue.offer(token);
                    }
                } else if (!atQueue.isEmpty()) {
                    if (!hasStartTime) {
                        atQueue.poll();
                        startTime = token;
                        hasStartTime = true;
                    } else {
                        descriptionQueue.offer(atQueue.poll());
                        descriptionQueue.offer(token);
                    }
                } else if (!fromQueue.isEmpty()) {
                    if (!hasStartTime) {
                        fromQueue.poll();
                        startTime = token;
                        hasStartTime = true;
                    } else {
                        descriptionQueue.offer(fromQueue.poll());
                        descriptionQueue.offer(token);
                    }
                } else if (!toQueue.isEmpty()) {
                    if (!hasEndTime) {
                        toQueue.poll();
                        endTime = token;
                        hasEndTime = true;
                    } else {
                        descriptionQueue.offer(toQueue.poll());
                        descriptionQueue.offer(token);
                    }
                } else if (!onQueue.isEmpty()) {
                    descriptionQueue.offer(onQueue.poll());
                    descriptionQueue.offer(token);
                }
            }
        }

        String tempToken = flushQueue(byQueue, onQueue, atQueue, fromQueue, toQueue);
        if (!tempToken.isEmpty()) {
            descriptionQueue.offer(tempToken);
        }

        while (!descriptionQueue.isEmpty()) {
            description += descriptionQueue.poll() + " ";
        }
        description.trim();

        if (!hasEndDate) {
            endDate = startDate;
        }
        
        if ((TaskDate.isValidToday(startDate) && !hasStartTime) || startDate.equals(TaskDate.DEFAULT_DATE) && !hasStartTime) {
            startTime = TaskTime.getTimeNow().toString();
        }

        if (hasStartDate || hasEndDate || hasStartTime || hasEndTime) {
            try {
                return new AddCommand(description, Task.EVENT_TASK, startDate, endDate, startTime, endTime,
                        taskPriority, getTagsFromArgs(tagString));
            } catch (IllegalValueException ive) {
                UndoCommand.deletePreviousCommand();
                return new IncorrectCommand(ive.getMessage());
            }
        } else {
            try {
                return new AddCommand(description, Task.FLOATING_TASK, startDate, endDate, startTime, endTime,
                        taskPriority, getTagsFromArgs(tagString));
            } catch (IllegalValueException ive) {
                UndoCommand.deletePreviousCommand();
                return new IncorrectCommand(ive.getMessage());
            }
        }

    }

    private String flushQueue(Queue<String> byQueue, Queue<String> onQueue, Queue<String> atQueue,
            Queue<String> fromQueue, Queue<String> toQueue) {
        String token = "";

        if (!byQueue.isEmpty()) {
            token = byQueue.poll();
        } else if (!onQueue.isEmpty()) {
            token = onQueue.poll();
        } else if (!atQueue.isEmpty()) {
            token = atQueue.poll();
        } else if (!fromQueue.isEmpty()) {
            token = fromQueue.poll();
        } else if (!toQueue.isEmpty()) {
            token = toQueue.poll();
        }

        return token;
    }

    private Queue<String> initialiseArgQueue(ArrayList<String> argsList) {
        Queue<String> argsQueue = new LinkedList<String>();
        for (String arg : argsList) {
            argsQueue.offer(arg);
        }
        return argsQueue;
    }

    private ArrayList<String> tokenizeArguments(String args) {
        ArrayList<String> argsList = new ArrayList<String>();
        StringTokenizer st = new StringTokenizer(args, " ");
        while (st.hasMoreTokens()) {
            argsList.add(st.nextToken());
        }
        return argsList;
    }
```
###### \java\seedu\taskell\model\task\Description.java
``` java
/**
 * Represents a Task's description in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidDescription(String)}
 */
public class Description {

    public static final String MESSAGE_DESCRIPTION_CONSTRAINTS = "Task description should be spaces or alphanumeric characters";

    public String description;

    /**
     * Validates given description.
     *
     * @throws IllegalValueException if given description string is invalid.
     */
    public Description(String description) throws IllegalValueException {
        assert description != null;
        description = description.trim();
        if (!isValidDescription(description)) {
            throw new IllegalValueException(MESSAGE_DESCRIPTION_CONSTRAINTS);
        }
        this.description = description;
    }

    /**
     * Returns true if a given string is a valid task description.
     */
    public static boolean isValidDescription(String test) {
        return !test.isEmpty();
    }

    public void setDescription(String description){
        this.description = description;
    }
    
    @Override
    public String toString() {
        return description;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Description // instanceof handles nulls
                && this.description.equals(((Description) other).description)); // state check
    }

    @Override
    public int hashCode() {
        return description.hashCode();
    }

}
```
###### \java\seedu\taskell\model\task\EventTask.java
``` java
/**
 * Represents an Event task in the task manager.
 * Guarantees: details are present and not null, field values are validated.
 */
public class EventTask extends Task {
    public static final String MESSAGE_EVENT_CONSTRAINTS = "Start date and time must be before end date and time"
            + "\nAll date and time should not before current time";

    public EventTask(String description, String startDate, String endDate, String startTime, String endTime, String taskPriority, String taskStatus, UniqueTagList tags) throws IllegalValueException {
        this(new Description(description),
                EVENT_TASK,
                new TaskDate(startDate),
                new TaskDate(endDate),
                new TaskTime(startTime),
                new TaskTime(endTime),
                new TaskPriority(taskPriority),
                new TaskStatus(taskStatus),
                tags);
    }
    /**
     * Every field must be present and not null.
     * @throws IllegalValueException 
     */
    public EventTask(Description description, String taskType, TaskDate startDate, TaskDate endDate, TaskTime startTime, TaskTime endTime, TaskPriority taskPriority, TaskStatus taskStatus, UniqueTagList tags) throws IllegalValueException {
        endDate = autoAdjustEndDate(startDate, endDate, startTime, endTime);
        
        if (!isValidEventDuration(startDate, endDate, startTime, endTime)) {
            throw new IllegalValueException(MESSAGE_EVENT_CONSTRAINTS);
        }
        
        this.description = description;
        this.taskType = EVENT_TASK;
        this.startDate = startDate;
        this.endDate = endDate;
        this.startTime = startTime;
        this.endTime = endTime;
        this.taskPriority = taskPriority;
        this.taskStatus = taskStatus;
        this.tags = tags;
    }
    
    private boolean isValidEventDuration(TaskDate startDate, TaskDate endDate, TaskTime startTime, TaskTime endTime) {
        TaskDate today = TaskDate.getTodayDate();
        TaskTime currentTime = TaskTime.getTimeNow();
        
        if (startDate.isBefore(today) || endDate.isBefore(today)) {
            return false;
        } else if (startDate.isAfter(endDate)) {
            return false;
        } if (startDate.equals(today) && startTime.isBefore(currentTime)) { 
            return false;
        } else {
            return true;
        }
    }
    
    /**
     * Adjust the endDate such that it fits into the real-world context
     * @throws IllegalValueException
     */
    private TaskDate autoAdjustEndDate(TaskDate startDate, TaskDate endDate, TaskTime startTime, TaskTime endTime) throws IllegalValueException {
        TaskDate today = TaskDate.getTodayDate();
        if (startDate.equals(endDate) && startTime.isAfter(endTime)) {
            endDate = endDate.getNextDay();
        } else if (startDate.getDayNameInWeek().equals(today.getDayNameInWeek())
                && !endDate.getDayNameInWeek().equals(today.getDayNameInWeek())) {
            endDate = endDate.getNextWeek();
        }
        return endDate;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }
}
```
###### \java\seedu\taskell\model\task\FloatingTask.java
``` java
/**
 * Represents a Floating Task in the task manager.
 * Guarantees: details are present and not null, field values are validated.
 */
public class FloatingTask extends Task {

    public FloatingTask(String description, String taskPriority, String taskStatus, UniqueTagList tags) throws IllegalValueException {
        this(new Description(description),
                FLOATING_TASK,
                new TaskDate(TaskDate.DEFAULT_DATE),
                new TaskDate(TaskDate.DEFAULT_DATE),
                new TaskTime(TaskTime.DEFAULT_START_TIME),
                new TaskTime(TaskTime.DEFAULT_END_TIME),
                new TaskPriority(taskPriority),
                new TaskStatus(taskStatus),
                tags);
    }
    
    public FloatingTask(Description description, String taskType, TaskDate startDate, TaskDate endDate, TaskTime startTime, TaskTime endTime, TaskPriority taskPriority, TaskStatus taskStatus, UniqueTagList tags) {
        super(description, taskType, startDate, endDate, startTime, endTime, taskPriority, taskStatus, tags);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

}
```
###### \java\seedu\taskell\model\task\TaskDate.java
``` java
/**
 * Represents a Task's taskDate in the task manager.
 * Guarantees: is valid as declared in {@link #isValidDate(String)}
 */
public class TaskDate {
    public static final int JANUARY = 1;
    public static final int FEBRUARY = 2;
    public static final int MARCH = 3;
    public static final int APRIL = 4;
    public static final int MAY = 5;
    public static final int JUNE = 6;
    public static final int JULY = 7;
    public static final int AUGUST = 8;
    public static final int SEPTEMBER = 9;
    public static final int OCTOBER = 10;
    public static final int NOVEMBER = 11;
    public static final int DECEMBER = 12;

    public static final int MONDAY = 1;
    public static final int TUESDAY = 2;
    public static final int WEDNESDAY = 3;
    public static final int THURSDAY = 4;
    public static final int FRIDAY = 5;
    public static final int SATURDAY = 6;
    public static final int SUNDAY = 7;

    public static final int NUM_DAYS_IN_A_WEEK = 7;
    public static final int NUM_MONTHS_IN_A_YEAR = 12;
    
    public static final int NOT_A_VALID_MONTH = 0;
    public static final int NOT_A_VALID_DAY_OF_THE_WEEK = 0;

    public static final int FIRST_DAY_OF_THE_MONTH = 1;
    
    public static final String DATE_DELIMITER = " .-/";
    
    public static final String DEFAULT_DATE = getDefaultDate();

    public static final Pattern TASK_DATE_ARGS_FORMAT = Pattern
            .compile("(?<day>(3[0-1]|2[0-9]|1[0-9]|[1-9]))" + "(-)(?<month>(1[0-2]|[1-9]))" + "(-)(?<year>([0-9]{4}))");
    private static final DateTimeFormatter dtf = DateTimeFormatter.ofPattern("EEEE, d MMMM yyyy");
    private static final DateTimeFormatter standardFormat = DateTimeFormatter.ofPattern("d-MM-yyyy");
    SimpleDateFormat sdf = new SimpleDateFormat("d M yyyy");
    
    public static final String MESSAGE_TASK_DATE_CONSTRAINTS =
            "Task dates should be separated by '-' or '.' or '/'"
            + "\nSpelling of month should be in full or 3-letters"
            + "\nYear should only be 4-digits";

    public String taskDate;
    
    /**
     * Initialize the different fields given taskDate in the format of 
     * DAY-MONTH-YEAR, separated by DATE_DELIMITER
     * @throws IllegalValueException 
     */
    public TaskDate(String dateToAdd) throws IllegalValueException {
        if (isValidFullDate(dateToAdd)) {
            setDateGivenFullDate(dateToAdd);
        } else if (isValidDayAndMonth(dateToAdd)) {
            setDateGivenDayMonth(dateToAdd);
        } else if (isValidMonthAndYear(dateToAdd)) {
            setDateGivenMonthYear(dateToAdd);
        } else if (isValidMonth(dateToAdd)) {
            setDateGivenMonth(dateToAdd);
        } else if (isValidDayOfWeek(dateToAdd)) {
            setDateGivenDayNameOfWeek(dateToAdd);
        } else if (isValidToday(dateToAdd)) {
            setDateGivenToday(dateToAdd);
        } else if (isValidTomorrow(dateToAdd)) {
            setDateGivenTomorrow(dateToAdd);
        } else {
            throw new IllegalValueException(MESSAGE_TASK_DATE_CONSTRAINTS);
        }
    }
    
    /**
     * Extract the different fields from taskDate having the format of
     * DAY-MONTH-YEAR, separated by DATE_DELIMITER
     * @throws DateTimeException
     * @throws IllegalValueException 
     */
    private void setDateGivenFullDate(String dateToConvert) throws DateTimeException, IllegalValueException {
        StringTokenizer st = new StringTokenizer(dateToConvert, DATE_DELIMITER);
        String[] tokenArr = new String[3];
        int i = 0;
        while (st.hasMoreTokens()) {
            tokenArr[i] = st.nextToken();
            i++;
        }

        int day = Integer.valueOf(tokenArr[0]);
        String monthStr = tokenArr[1];
        int month;
        try {
            month = Integer.valueOf(tokenArr[1]);
        } catch (NumberFormatException nfe) {
            month = convertMonthIntoInteger(monthStr);
        }
        int year = Integer.valueOf(tokenArr[2]);

        try {
            setDate(day, month, year);
            getYear();
        } catch (IllegalValueException ive) {
            throw ive;
        }
    }
    
    private void setDateGivenDayMonth(String dateToConvert) throws IllegalValueException {
        StringTokenizer st = new StringTokenizer(dateToConvert, DATE_DELIMITER);
        String[] tokenArr = new String[3];
        int i = 0;
        while (st.hasMoreTokens()) {
            tokenArr[i] = st.nextToken();
            i++;
        }

        int day = Integer.valueOf(tokenArr[0]);
        String monthStr = tokenArr[1];
        int month;
        try {
            month = Integer.valueOf(tokenArr[1]);
        } catch (NumberFormatException nfe) {
            month = convertMonthIntoInteger(monthStr);
        }
        int year = Integer.valueOf(getThisYear());

        try {
            setDate(day, month, year);
            getYear();
        } catch (IllegalValueException ive) {
            throw ive;
        }
    }

    private void setDateGivenMonthYear(String dateToConvert) throws IllegalValueException {
        StringTokenizer st = new StringTokenizer(dateToConvert, DATE_DELIMITER);
        String[] tokenArr = new String[3];
        int i = 0;
        while (st.hasMoreTokens()) {
            tokenArr[i] = st.nextToken();
            i++;
        }

        int day = FIRST_DAY_OF_THE_MONTH;
        String monthStr = tokenArr[0];
        int month;
        try {
            month = Integer.valueOf(tokenArr[0]);
        } catch (NumberFormatException nfe) {
            month = convertMonthIntoInteger(monthStr);
        }
        int year = Integer.valueOf(tokenArr[1]);

        try {
            setDate(day, month, year);
            getYear();
        } catch (IllegalValueException ive) {
            throw ive;
        }
    }
    
    private void setDateGivenMonth(String monthToConvert) {
        int day = FIRST_DAY_OF_THE_MONTH;
        int month = convertMonthIntoInteger(monthToConvert);
        int year = Integer.valueOf(getThisYear());

        try {
            setDate(day, month, year);
        } catch (DateTimeException dte) {
            throw dte;
        }
    }
    
    private void setDateGivenDayNameOfWeek(String dayName) {
        int day = convertDayOfWeekIntoInteger(dayName);
        LocalDate today = LocalDate.now();
        String todayDayNameInWeek = today.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.US);
        int todayDayInWeek = convertDayOfWeekIntoInteger(todayDayNameInWeek);
        int daysToAdd = day - todayDayInWeek;
        if (daysToAdd <= 0) {
            daysToAdd += NUM_DAYS_IN_A_WEEK;
        }
        LocalDate finalDate = today.plusDays(daysToAdd);
        setDate(finalDate.getDayOfMonth(), finalDate.getMonthValue(), finalDate.getYear());
    }
    
    private void setDateGivenToday(String taskDate) {
        LocalDate today = LocalDate.now();
        setDate(today.getDayOfMonth(), today.getMonthValue(), today.getYear());
    }
    
    private void setDateGivenTomorrow(String taskDate) {
        LocalDate today = LocalDate.now();
        LocalDate tomorrow = today.plusDays(1);
        setDate(tomorrow.getDayOfMonth(), tomorrow.getMonthValue(), tomorrow.getYear());
    }
    
    /**
     * Extract the different fields of a given valid taskDate
     * @throws DateTimeException
     */
    public void setDate(int day, int month, int year) {
        this.taskDate = convertToStandardFormat(day, month, year);
    }
    
    /**
     * Convert this TaskDate to the format of
     * DAY_MONTH-YEAR
     */
    public static String convertToStandardFormat(int day, int month, int year) {
        return day + "-" + month + "-" + year;
    }

    /**
     * Returns true if a given string is a valid task taskDate.
     */
    public static boolean isValidDate(String dateToValidate) {
        if (dateToValidate == null || dateToValidate.isEmpty()) {
            return false;
        }
        
        return isValidFullDate(dateToValidate) || isValidMonthAndYear(dateToValidate)
                || isValidDayAndMonth(dateToValidate) || isValidMonth(dateToValidate) || isValidToday(dateToValidate)
                || isValidTomorrow(dateToValidate) || isValidDayOfWeek(dateToValidate);
    }

    public static boolean isValidDayOfWeek(String dateToValidate) {
        if (convertDayOfWeekIntoInteger(dateToValidate) == NOT_A_VALID_DAY_OF_THE_WEEK) {
            return false;
        }
        return true;
    }

    public static boolean isValidMonthAndYear(String dateToValidate) {
        if (isValidFormat(dateToValidate, "MMM yyyy") || isValidFormat(dateToValidate, "MMM-yyyy")
                || isValidFormat(dateToValidate, "MMM.yyyy")
                || isValidFormat(dateToValidate, "MMM/yyyy")) {
            return true;
        }
        return false;
    }

    public static boolean isValidDayAndMonth(String dateToValidate) {
        if (isValidFormat(dateToValidate, "d MMM") || isValidFormat(dateToValidate, "d-MMM")
                || isValidFormat(dateToValidate, "d.MMM")
                || isValidFormat(dateToValidate, "d/MMM")) {
            return true;
        }
        return false;
    }

    public static boolean isValidFullDate(String dateToValidate) {
        if (isValidFormat(dateToValidate, "d M yyyy") || isValidFormat(dateToValidate, "d MMM yyyy")
                || isValidFormat(dateToValidate, "d-M-yyyy") || isValidFormat(dateToValidate, "d-MMM-yyyy")
                || isValidFormat(dateToValidate, "d.M.yyyy") || isValidFormat(dateToValidate, "d.MMM.yyyy")
                || isValidFormat(dateToValidate, "d.M-yyyy") || isValidFormat(dateToValidate, "d.MMM-yyyy")
                || isValidFormat(dateToValidate, "d-M.yyyy") || isValidFormat(dateToValidate, "d-MMM.yyyy")
                || isValidFormat(dateToValidate, "d/M/yyyy") || isValidFormat(dateToValidate, "d/MMM/yyyy")
                || isValidFormat(dateToValidate, "d-M/yyyy") || isValidFormat(dateToValidate, "d-MMM/yyyy")
                || isValidFormat(dateToValidate, "d/M-yyyy") || isValidFormat(dateToValidate, "d/MMM-yyyy")
                || isValidFormat(dateToValidate, "d.M/yyyy") || isValidFormat(dateToValidate, "d.MMM/yyyy")
                || isValidFormat(dateToValidate, "d/M.yyyy") || isValidFormat(dateToValidate, "d/MMM.yyyy")) {
            return true;
        }
        return false;
    }

    /**
     * Returns true if a given string has a valid format supported by SimpleDateFormat.
     */
    public static boolean isValidFormat(String dateToValidate, String acceptedFormat) {
        if (dateToValidate == null) {
            return false;
        }

        SimpleDateFormat sdf = new SimpleDateFormat(acceptedFormat);
        sdf.setLenient(false);

        try {
            // if not valid, it will throw ParseException
            Date taskDate = sdf.parse(dateToValidate);
        } catch (ParseException e) {
            return false;
        }

        return true;
    }

    public static boolean isValidToday(String dateToValidate) {
        assert (dateToValidate != null);
        dateToValidate = dateToValidate.toLowerCase();
        
        switch (dateToValidate) {
        case "today":
            // Fallthrough
        case "tdy":
            return true;
        default:
            return false;
        }
    }

    public static boolean isValidTomorrow(String dateToValidate) {
        assert (dateToValidate != null);
        dateToValidate = dateToValidate.toLowerCase();
        
        switch (dateToValidate) {
        case "tomorrow":
            // Fallthrough
        case "tmr":
            return true;
        default:
            return false;
        }
    }

    public static boolean isValidMonth(String month) {
        if (convertMonthIntoInteger(month) == NOT_A_VALID_MONTH) {
            return false;
        } else {
            return true;
        }
    }

    /**
     * Returns an integer representing the day in a week
     */
    private static int convertDayOfWeekIntoInteger(String day) {
        assert (day != null);
        day = day.toLowerCase();

        switch (day) {
        case "mon":
            // Fallthrough
        case "monday":
            return MONDAY;
        case "tue":
            // Fallthrough
        case "tues":
            // Fallthrough
        case "tuesday":
            return TUESDAY;
        case "wed":
            // Fallthrough
        case "wednesday":
            return WEDNESDAY;
        case "thu":
            // Fallthrough
        case "thur":
            // Fallthrough
        case "thurs":
            // Fallthrough
        case "thursday":
            return THURSDAY;
        case "fri":
            // Fallthrough
        case "friday":
            return FRIDAY;
        case "sat":
            // Fallthrough
        case "saturday":
            return SATURDAY;
        case "sun":
            // Fallthrough
        case "sunday":
            return SUNDAY;
        default:
            return NOT_A_VALID_DAY_OF_THE_WEEK;
        }
    }

    /**
     * Returns an integer representing the month of a year.
     */
    private static int convertMonthIntoInteger(String month) {
        assert (month!= null);
        if (Character.isLetter(month.charAt(0))) {
            month = month.toLowerCase();
        }

        switch (month) {
        case "jan":
            // Fallthrough
        case "january":
            return JANUARY;
        case "feb":
            // Fallthrough
        case "february":
            return FEBRUARY;
        case "mar":
            // Fallthrough
        case "march":
            return MARCH;
        case "apr":
            // Fallthrough
        case "april":
            return APRIL;
        case "may":
            return MAY;
        case "jun":
            // Fallthrough
        case "june":
            return JUNE;
        case "jul":
            // Fallthrough
        case "july":
            return JULY;
        case "aug":
            // Fallthrough
        case "august":
            return AUGUST;
        case "sep":
            // Fallthrough
        case "sept":
            // Fallthrough
        case "september":
            return SEPTEMBER;
        case "oct":
            // Fallthrough
        case "october":
            return OCTOBER;
        case "nov":
            // Fallthrough
        case "november":
            return NOVEMBER;
        case "dec":
            // Fallthrough
        case "december":
            return DECEMBER;
        default:
            return NOT_A_VALID_MONTH;
        }
    }

    /**
     * Get today's taskDate in the format of
     * DAY-MONTH-YEAR
     */
    public static TaskDate getTodayDate() {
        try {
            return new TaskDate(LocalDate.now().format(standardFormat));
        } catch (IllegalValueException e) {
            return null;
        }
    }

    /**
     * Get tomorrow's taskDate in the format of
     * DAY-MONTH-YEAR
     */
    public static TaskDate getTomorrowDate() {
        try {
            return new TaskDate(LocalDate.now().plusDays(1).format(standardFormat));
        } catch (IllegalValueException e) {
            return null;
        }
    }
    
    public TaskDate getNextDay() throws IllegalValueException {
        try {
            LocalDate localDate = LocalDate.of(Integer.valueOf(getYear()), Integer.valueOf(getMonth()), Integer.valueOf(getDay()));
            LocalDate nextDay = localDate.plusDays(1);
            return new TaskDate(nextDay.format(standardFormat));
        } catch (IllegalValueException e) {
            throw new IllegalValueException(MESSAGE_TASK_DATE_CONSTRAINTS);
        }
    }
    
    public TaskDate getNextWeek() throws IllegalValueException {
        try {
            LocalDate localDate = LocalDate.of(Integer.valueOf(getYear()), Integer.valueOf(getMonth()), Integer.valueOf(getDay()));
            LocalDate nextWeek = localDate.plusWeeks(1);
            return new TaskDate(nextWeek.format(standardFormat));
        } catch (IllegalValueException e) {
            throw new IllegalValueException(MESSAGE_TASK_DATE_CONSTRAINTS);
        }
    }

    /**
     * Returns a string representing the integer value of this year
     */
    public static String getThisYear() {
        return LocalDate.now().getYear() + "";
    }
    
    public String getDay() throws IllegalValueException {
        assert taskDate != null;
        
        final Matcher matcherFullArg = TASK_DATE_ARGS_FORMAT.matcher(taskDate.trim());
        if (matcherFullArg.matches()) {
            return matcherFullArg.group("day");
        } else {
            throw new IllegalValueException(MESSAGE_TASK_DATE_CONSTRAINTS);
        }
    }
    
    public String getMonth() throws IllegalValueException {
        assert taskDate != null;
        
        final Matcher matcherFullArg = TASK_DATE_ARGS_FORMAT.matcher(taskDate.trim());
        if (matcherFullArg.matches()) {
            return matcherFullArg.group("month");
        } else {
            throw new IllegalValueException(MESSAGE_TASK_DATE_CONSTRAINTS);
        }
    }
    
    public String getYear() throws IllegalValueException {
        assert taskDate != null;
        
        final Matcher matcherFullArg = TASK_DATE_ARGS_FORMAT.matcher(taskDate.trim());
        if (matcherFullArg.matches()) {
            return matcherFullArg.group("year");
        } else {
            throw new IllegalValueException(MESSAGE_TASK_DATE_CONSTRAINTS);
        }
    }
    
    public String getDayNameInWeek() throws IllegalValueException {
        try {
            LocalDate localDate = LocalDate.of(Integer.valueOf(getYear()), Integer.valueOf(getMonth()), Integer.valueOf(getDay()));
            String dayNameInWeek = localDate.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.US);
            return dayNameInWeek;
        } catch (IllegalValueException ive) {
            throw ive;
        }
    }
    
    public String getMonthName() throws IllegalValueException {
        try {
            LocalDate localDate = LocalDate.of(Integer.valueOf(getYear()), Integer.valueOf(getMonth()), Integer.valueOf(getDay()));
            String month = localDate.getMonth().getDisplayName(TextStyle.FULL, Locale.US);
            return month;
        } catch (IllegalValueException ive) {
            throw ive;
        }
    }
    
    public String getDisplayDate() {
        try {
            return getDayNameInWeek() + ", " + getDay() + " " + getMonthName() + " " + getYear();
        } catch (IllegalValueException e) {
            return "";
        }
    }

    public static String getDefaultDate() {
        int day = LocalDate.now().getDayOfMonth();
        int month = LocalDate.now().getMonthValue();
        int year = LocalDate.now().getYear();
        return convertToStandardFormat(day, month, year);
    }
    
    public boolean isBefore(TaskDate date) {
        try {
            LocalDate thisDate = LocalDate.of(Integer.valueOf(this.getYear()), Integer.valueOf(this.getMonth()), Integer.valueOf(this.getDay()));
            LocalDate dateToComapare = LocalDate.of(Integer.valueOf(date.getYear()), Integer.valueOf(date.getMonth()), Integer.valueOf(date.getDay()));
            return thisDate.isBefore(dateToComapare);
        } catch (Exception e) {
            return false;
        }
    }
    
    public boolean isAfter(TaskDate date) {
        try {
            LocalDate thisDate = LocalDate.of(Integer.valueOf(this.getYear()), Integer.valueOf(this.getMonth()), Integer.valueOf(this.getDay()));
            LocalDate dateToComapare = LocalDate.of(Integer.valueOf(date.getYear()), Integer.valueOf(date.getMonth()), Integer.valueOf(date.getDay()));
            return thisDate.isAfter(dateToComapare);
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Returns a string with the format of
     * DAY-MONTH-YEAR
     */
    @Override
    public String toString() {
        return taskDate;
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskDate // instanceof handles nulls
                && this.taskDate.equals(((TaskDate)other).taskDate));
    }

    @Override
    public int hashCode() {
        return taskDate.hashCode();
    }

}
```
###### \java\seedu\taskell\model\task\TaskPriority.java
``` java
/**
 * Represents a Task's priority in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidPriority(String)}
 */
public class TaskPriority {
    
    public static final String MESSAGE_TASK_PRIORITY_CONSTRAINTS = "Task priority should range from 0-3"
            + "\nThere should not be more than 1 priority level for a task";
    public static final String TASK_PRIORITY_VALIDATION_REGEX = ".+";
    
    public static final String PREFIX = "p/";
    
    public static final String NO_PRIORITY = "0";
    public static final String LOW_PRIORITY = "1";
    public static final String MEDIUM_PRIORITY = "2";
    public static final String HIGH_PRIORITY = "3";
    
    public static final String DEFAULT_PRIORITY = NO_PRIORITY;
    
    public static final String LOW_PRIORITY_BACKGROUND = "-fx-background-color:#4ca64c";
    public static final String MEDIUM_PRIORITY_BACKGROUND = "-fx-background-color:#ffff4c";
    public static final String HIGH_PRIORITY_BACKGROUND = "-fx-background-color:#ff4c4c";

    public final String taskPriority;

    /**
     * Validates given priority.
     *
     * @throws IllegalValueException if given priority string is invalid.
     */
    public TaskPriority(String priority) throws IllegalValueException {
        assert priority != null;
        if (!isValidPriority(priority)) {
            throw new IllegalValueException(MESSAGE_TASK_PRIORITY_CONSTRAINTS);
        }
        this.taskPriority = priority;
    }

    /**
     * Returns true if a given string is a valid task taskTime.
     */
    public static boolean isValidPriority(String priority) {
        return priority.equals(NO_PRIORITY)
                || priority.equals(LOW_PRIORITY) 
                || priority.equals(MEDIUM_PRIORITY)
                || priority.equals(HIGH_PRIORITY);
    }

    @Override
    public String toString() {
        return taskPriority;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskPriority // instanceof handles nulls
                && this.taskPriority.equals(((TaskPriority) other).taskPriority)); // state check
    }

    @Override
    public int hashCode() {
        return taskPriority.hashCode();
    }

}
```
###### \java\seedu\taskell\model\task\TaskTime.java
``` java
/**
 * Represents a Task's taskTime in the task manager.
 */
public class TaskTime {

    public static final String ZERO_MINUTE = "00";
    public static final String NOON = "12:00PM";
    public static final String MIDNIGHT = "12:00AM";
    
    public static final String AM = "AM";
    public static final String PM = "PM";
    
    public static final int TIME_OFFSET = 12;
    
    public static final DateTimeFormatter dtf = DateTimeFormatter.ofPattern("h:mma");
    
    public static final String DEFAULT_START_TIME = MIDNIGHT;
    public static final String DEFAULT_END_TIME = "11:59PM";

    public static final Pattern TASK_TIME_ARGS_FORMAT = Pattern
            .compile("(?<hour>(1[0-2]|[1-9]))" + "(.|-|:)(?<minute>([0-5][0-9]))" + "(?<antePost>(am|pm|AM|PM|Am|Pm|aM|pM))");
    public static final Pattern TASK_TIME_HOUR_ONLY_FORMAT = Pattern
            .compile("(?<hour>(1[0-2]|[1-9]))" + "(?<antePost>(am|pm|AM|PM|Am|Pm|aM|pM))");
    final static String FULL_TIME_REGEX = "^(1[0-2]|[1-9])(.|-|:)([0-5][0-9])(am|pm|AM|PM|Am|Pm|aM|pM)$";
    final static String HOUR_ONLY_TIME_REGEX = "^(1[0-2]|[1-9])(am|pm|AM|PM|Am|Pm|aM|pM)$";
    
    public static final String MESSAGE_TASK_TIME_CONSTRAINTS =
            "Time should be in 12hour clock format."
            + "\nHour and Minute are separated by '.' or ':'"
            + "\nEg. 9.30am or 12:50pm";

    public String taskTime; //Standard format

    public TaskTime(String time) throws IllegalValueException {
        if (isValidTime(time)) {
            setTime(time);
        } else {
            throw new IllegalValueException(MESSAGE_TASK_TIME_CONSTRAINTS);
        }
    }

    public static boolean isValidTime(String time) {
        assert time != null;
        if (time.isEmpty()) {
            return false;
        }

        if (time.matches(HOUR_ONLY_TIME_REGEX) || time.matches(FULL_TIME_REGEX)) {
            return true;
        } else if (isValidNow(time)) {
            return true;
        } else if (isValidNoon(time)) {
            return true;
        } else if (isValidMidnight(time)) {
            return true;
        } else {
            return false;
        }
    }
    
    private static boolean isValidNow(String time) {
        time = time.toLowerCase();
        switch (time) {
        case "now":
            return true;
        default:
            return false;
        }
    }
    
    private static boolean isValidNoon(String time) {
        time = time.toLowerCase();
        switch (time) {
        case "afternoon":
            //Fallthrough
        case "noon":
            //Fallthrough
        case "12noon":
            //Fallthrough
        case "12-noon":
            return true;
        default:
            return false;
        }
    }
    
    private static boolean isValidMidnight(String time) {
        time = time.toLowerCase();
        switch (time) {
        case "midnight":
            //Fallthrough
        case "mid-night":
            //Fallthrough
        case "12midnight":
            //Fallthrough
        case "12-midnight":
            //Fallthrough
        case "12mid-night":
            //Fallthrough
        case "12-mid-night":
            //Fallthrough
            return true;
        default:
            return false;
        }
    }
    
    /**
     * Checks if this time is before the specified time
     */
    public boolean isBefore(TaskTime time) {
        int timeHour = Integer.valueOf(time.getHour());
        if (time.getAntePost().equals(PM) && (timeHour != TIME_OFFSET)) {
            timeHour += TIME_OFFSET;
        } else if (time.getAntePost().equals(AM) && (timeHour == TIME_OFFSET)) {
            timeHour -= TIME_OFFSET;
        }
        LocalTime timeToCompare = LocalTime.of(timeHour, Integer.valueOf(time.getMinute()));
        
        //TaskTime thisTimeTaskTime = new TaskTime(this.taskTime);
        int thisTimeHour = Integer.valueOf(this.getHour());
        if (this.getAntePost().equals(PM) && (thisTimeHour != TIME_OFFSET)) {
            thisTimeHour += TIME_OFFSET;
        } else if (this.getAntePost().equals(AM) && (thisTimeHour == TIME_OFFSET)) {
            thisTimeHour -= TIME_OFFSET;
        }
        LocalTime thisTimeLocalTime = LocalTime.of(thisTimeHour, Integer.valueOf(this.getMinute()));
        return thisTimeLocalTime.isBefore(timeToCompare);
    }

    /**
     * Checks if this time is after the specified time
     */
    public boolean isAfter(TaskTime time) {
        int timeHour = Integer.valueOf(time.getHour());
        if (time.getAntePost().equals(PM) && (timeHour != TIME_OFFSET)) {
            timeHour += TIME_OFFSET;
        } else if (time.getAntePost().equals(AM) && (timeHour == TIME_OFFSET)) {
            timeHour -= TIME_OFFSET;
        }
        LocalTime timeToCompare = LocalTime.of(timeHour, Integer.valueOf(time.getMinute()));
        
        //TaskTime thisTimeTaskTime = new TaskTime(this.taskTime);
        int thisTimeHour = Integer.valueOf(this.getHour());
        if (this.getAntePost().equals(PM) && (thisTimeHour != TIME_OFFSET)) {
            thisTimeHour += TIME_OFFSET;
        } else if (this.getAntePost().equals(AM) && (thisTimeHour == TIME_OFFSET)) {
            thisTimeHour -= TIME_OFFSET;
        }
        LocalTime thisTimeLocalTime = LocalTime.of(thisTimeHour, Integer.valueOf(this.getMinute()));
        return thisTimeLocalTime.isAfter(timeToCompare);
    }
    
    public void setTime(String time) throws IllegalValueException {
        final Matcher matcherFullArg = TASK_TIME_ARGS_FORMAT.matcher(time.trim());
        final Matcher matcherHourOnly = TASK_TIME_HOUR_ONLY_FORMAT.matcher(time.trim());
        if (matcherFullArg.matches()) {
            this.taskTime = setTime(matcherFullArg.group("hour"), matcherFullArg.group("minute"), matcherFullArg.group("antePost"));
        } else if (matcherHourOnly.matches()) {
            this.taskTime = setTime(matcherHourOnly.group("hour"), ZERO_MINUTE, matcherHourOnly.group("antePost"));
        } else if (isValidNow(time)) {
            this.taskTime = getTimeNow().toString();
        } else if (isValidNoon(time)) {
            this.taskTime = NOON;
        } else if (isValidMidnight(time)) {
            this.taskTime = MIDNIGHT;
        } else {
            throw new IllegalValueException(MESSAGE_TASK_TIME_CONSTRAINTS);
        }
    }
    
    public String setTime(String hour, String minute, String antePost) {
        this.taskTime =  hour + ":" + minute + antePost.toUpperCase();
        return taskTime;
    }

    public static TaskTime getTimeNow() {
        LocalTime currTime = LocalTime.now();
        try {
            return new TaskTime(LocalTime.of(currTime.getHour(), currTime.getMinute()).format(dtf));
        } catch (IllegalValueException e) {
            return null;
        }
    }
    
    public String getHour() {
        assert taskTime != null;
        
        final Matcher matcherFullArg = TASK_TIME_ARGS_FORMAT.matcher(taskTime.trim());
        if (matcherFullArg.matches()) {
            return matcherFullArg.group("hour");
        }
        
        return "";
    }
    
    public String getMinute() {
        assert taskTime != null;
        
        final Matcher matcherFullArg = TASK_TIME_ARGS_FORMAT.matcher(taskTime.trim());
        if (matcherFullArg.matches()) {
            return matcherFullArg.group("minute");
        }
        
        return "";
    }
    
    public String getAntePost() {
        assert taskTime != null;
        
        final Matcher matcherFullArg = TASK_TIME_ARGS_FORMAT.matcher(taskTime.trim());
        if (matcherFullArg.matches()) {
            return matcherFullArg.group("antePost");
        }
        
        return "";
    }
    
    @Override
    public String toString() {
        return taskTime;
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskTime // instanceof handles nulls
                && this.taskTime.equals(((TaskTime) other).taskTime)); // state check
    }
    
    @Override
    public int hashCode() {
        return (taskTime).hashCode();
    }
}
```
###### \java\seedu\taskell\ui\TaskCard.java
``` java
    @FXML
    public void initialize() {
        id.setText(displayedIndex + ". ");
        description.setText(task.getDescription().description);
        tags.setText(task.tagsString());
        taskStatus.setText(task.getTaskStatus().taskStatus);
        
        setDateTime();
        setDateTimeVisibility();
        setCardPaneBackground();
    }
    
    private void setDateTime() {
        startDate.setText(task.getStartDate().getDisplayDate());
        endDate.setText(task.getEndDate().getDisplayDate());
        startTime.setText(task.getStartTime().taskTime);
        endTime.setText(task.getEndTime().taskTime);

    }
    
    private void setDateTimeVisibility() {
        if (task.getTaskType().equals(Task.FLOATING_TASK)) {
            startDate.setVisible(false);
            endDate.setVisible(false);
            startTime.setVisible(false);
            endTime.setVisible(false);
        }
        
    }
    
    private void setCardPaneBackground() {
        if (task.getTaskPriority().taskPriority.equals(TaskPriority.HIGH_PRIORITY)) {
            cardPane.setStyle(TaskPriority.HIGH_PRIORITY_BACKGROUND);
        } else if (task.getTaskPriority().taskPriority.equals(TaskPriority.MEDIUM_PRIORITY)) {
            cardPane.setStyle(TaskPriority.MEDIUM_PRIORITY_BACKGROUND);
        } else if (task.getTaskPriority().taskPriority.equals(TaskPriority.LOW_PRIORITY)) {
            cardPane.setStyle(TaskPriority.LOW_PRIORITY_BACKGROUND);
        }
    }
```
