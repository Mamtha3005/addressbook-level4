# A0142073R
###### \java\seedu\taskell\logic\commands\EditCommand.java
``` java
package seedu.taskell.logic.commands;

import seedu.taskell.commons.core.Messages;
import seedu.taskell.commons.core.UnmodifiableObservableList;
import seedu.taskell.commons.exceptions.IllegalValueException;
import seedu.taskell.history.HistoryManager;
import seedu.taskell.logic.commands.Command;
import seedu.taskell.logic.commands.CommandResult;
<<<<<<< Updated upstream
import seedu.taskell.logic.commands.UndoCommand;
=======
>>>>>>> Stashed changes
import seedu.taskell.model.task.Description;
import seedu.taskell.model.task.ReadOnlyTask;
import seedu.taskell.model.task.Task;
import seedu.taskell.model.task.TaskDate;
import seedu.taskell.model.task.TaskPriority;
import seedu.taskell.model.task.TaskTime;
import seedu.taskell.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.taskell.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Edits a task identified using it's last displayed index from the task
 * manager.
 */
public class EditCommand extends Command {
<<<<<<< Updated upstream
=======

>>>>>>> Stashed changes
    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits the different parts of a task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer) RESPECTIVE TASK PARAMETERS\n" + "Example: " + COMMAND_WORD
            + " 1 desc: buy cake st: 7am et: 8am sd: 11-12-2016 ed: 12-12-2016 p: 2\n";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Original Task: %1$s \n\nUpdated Task: %2$s";

    private final int targetIndex;

    private Description description;
    private TaskDate startDate;
    private TaskDate endDate;
    private TaskTime startTime;
    private TaskTime endTime;
    private TaskPriority taskPriority;

    private boolean[] hasComponentArray = new boolean[Task.NUM_BOOLEAN_TASK_COMPONENT];

<<<<<<< Updated upstream
    public EditCommand(int targetIndex, Description newDescription, boolean hasChangedDescription,
            TaskDate newStartDate, boolean hasChangedStartDate, TaskDate newEndDate, boolean hasChangedEndDate,
            TaskTime newStartTime, boolean hasChangedStartTime, TaskTime newEndTime, boolean hasChangedEndTime,
            TaskPriority newPriority, boolean hasChangedPriority) throws IllegalValueException {
=======
    public EditCommand(int targetIndex, Description newDescription, TaskDate newStartDate, TaskDate newEndDate,
            TaskTime newStartTime, TaskTime newEndTime, TaskPriority newPriority, boolean[] hasComponentArray)
            throws IllegalValueException {

>>>>>>> Stashed changes
        this.targetIndex = targetIndex;
        description = newDescription;
<<<<<<< Updated upstream
        this.hasChangedDescription = hasChangedDescription;
        startTime = newStartTime;
        this.hasChangedStartTime = hasChangedStartTime;
        endTime = newEndTime;
        this.hasChangedEndTime = hasChangedEndTime;
        startDate = newStartDate;
        this.hasChangedStartDate = hasChangedStartDate;
        endDate = newEndDate;
        this.hasChangedEndDate = hasChangedEndDate;
=======
        startTime = newStartTime;
        endTime = newEndTime;
        startDate = newStartDate;
        endDate = newEndDate;
>>>>>>> Stashed changes
        taskPriority = newPriority;

        this.hasComponentArray = hasComponentArray;
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

<<<<<<< Updated upstream
        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(targetIndex - 1);
        if (hasChangedDescription == false) {
=======
        if (hasComponentArray[Task.DESCRIPTION_COMPONENT] == false) {
>>>>>>> Stashed changes
            description = taskToEdit.getDescription();
        }
        if (hasComponentArray[Task.START_TIME_COMPONENT] == false) {
            startTime = taskToEdit.getStartTime();
        }
        if (hasComponentArray[Task.END_TIME_COMPONENT] == false) {
            endTime = taskToEdit.getEndTime();
        }
        if (hasComponentArray[Task.START_DATE_COMPONENT] == false) {
            startDate = taskToEdit.getStartDate();
        }
        if (hasComponentArray[Task.END_DATE_COMPONENT] == false) {
            endDate = taskToEdit.getEndDate();
        }
        if (hasComponentArray[Task.PRIORITY_COMPONENT] == false) {
            taskPriority = taskToEdit.getTaskPriority();
        }
<<<<<<< Updated upstream
=======
    }

    private boolean isValidDate(ReadOnlyTask taskToEdit) {
        if (taskToEdit.getTaskType().equals(Task.EVENT_TASK)) {
            if (endDate.isBefore(startDate)) {
                return false;
            } else {
                return true;
            }
        } else {
            return true;
        }
    }

    private boolean isValidTime(ReadOnlyTask taskToEdit) {
        TaskTime currentTime = TaskTime.getTimeNow();
        if (taskToEdit.getTaskType().equals(Task.EVENT_TASK)) {
            if (endDate.equals(startDate) && endTime.isBefore(startTime)) {
                try {
                    endDate = endDate.getNextDay();
                } catch (IllegalValueException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                return true;
            } else if (endDate.equals(startDate) && endTime.isBefore(currentTime)) {
                endTime = currentTime;
                return true;
            } else if (endDate.equals(startDate) && startTime.isBefore(currentTime)) {
                startTime = currentTime;
                return true;
            } else {
                return true;
            }
        } else {
            return true;
        }
    }

    private void jumpToNewTaskIndex() {
        jumpToIndex(targetIndex - 1);
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            HistoryManager.getInstance().deleteLatestCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(targetIndex - 1);
        getEditInformation(taskToEdit);

        if (taskToEdit.getTaskType().equals(Task.FLOATING_TASK) && (hasComponentArray[Task.START_TIME_COMPONENT] == true
                || hasComponentArray[Task.END_TIME_COMPONENT] == true
                || hasComponentArray[Task.START_DATE_COMPONENT] == true
                || hasComponentArray[Task.END_DATE_COMPONENT] == true)) {
            return new CommandResult(FloatingTask.EDIT_FLOATING_NOT_ALLOWED);
        }

        if (!isValidTime(taskToEdit)) {
            return new CommandResult(MESSAGE_TIME_CONSTRAINTS);
        }

        if (!isValidDate(taskToEdit)) {
            return new CommandResult(MESSAGE_DATE_CONSTRAINTS);
        }
>>>>>>> Stashed changes

        Task newTask = new Task(description, taskToEdit.getTaskType(), startDate, endDate, startTime, endTime,
                taskPriority, taskToEdit.getRecurringType(), taskToEdit.getTaskStatus(), taskToEdit.getTags());

        try {
            model.editTask(taskToEdit, newTask);
        } catch (TaskNotFoundException | DuplicateTaskException pnfe) {
            assert false : "The target task cannot be missing";
        } 

        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit, newTask));
    }
}
```
###### \java\seedu\taskell\logic\commands\list\ListDateCommand.java
``` java
package seedu.taskell.logic.commands.list;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import seedu.taskell.logic.commands.Command;
import seedu.taskell.logic.commands.CommandResult;
import seedu.taskell.model.task.Task;
import seedu.taskell.model.task.TaskDate;

public class ListDateCommand extends Command {

    public static final String COMMAND_WORD = "list-date";

    public static final String MESSAGE_SUCCESS = "Listed all tasks on a given date";

<<<<<<< Updated upstream
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Lists tasks on a specific date.\n"
=======
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Lists tasks on 1 specific date only.\n"
>>>>>>> Stashed changes
            + "Parameters: DATE (must be a positive integer)\n" + "Example: " + COMMAND_WORD + " 8-8-2016 ";

    private Set<String> keywordSet;

    public ListDateCommand(TaskDate date) {
        keywordSet = new HashSet<>(Arrays.asList(date.taskDate, Task.EVENT_TASK));
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredtaskListDate(keywordSet);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }
}
```
###### \java\seedu\taskell\logic\commands\list\ListPriorityCommand.java
``` java
package seedu.taskell.logic.commands.list;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import seedu.taskell.logic.commands.Command;
import seedu.taskell.logic.commands.CommandResult;
import seedu.taskell.model.task.TaskPriority;

public class ListPriorityCommand extends Command {

    public static final String COMMAND_WORD = "list-priority";

    public static final String MESSAGE_SUCCESS = "Listed all completed tasks in descending priority";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": List the task with the specified priority. "
            + "Parameters: INDEX (must be between 0 and 3 inclusive).\n"
            + "Example: " + COMMAND_WORD + " 1";
    
    private Set<String> mostImportant = new HashSet<>(Arrays.asList(TaskPriority.HIGH_PRIORITY));
    private Set<String> important = new HashSet<>(Arrays.asList(TaskPriority.MEDIUM_PRIORITY));
    private Set<String> lessImportant = new HashSet<>(Arrays.asList(TaskPriority.LOW_PRIORITY));
    private Set<String> leastImportant = new HashSet<>(Arrays.asList(TaskPriority.NO_PRIORITY));
    
    private Set<String> keyword;
    public ListPriorityCommand(String priority) {
        if(priority.equals(TaskPriority.HIGH_PRIORITY))
            keyword = mostImportant;
        else if(priority.equals(TaskPriority.MEDIUM_PRIORITY))
            keyword = important;
        else if(priority.equals(TaskPriority.LOW_PRIORITY))
            keyword = lessImportant;
        else
            keyword = leastImportant;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskListPriority(keyword);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }
}
```
###### \java\seedu\taskell\logic\parser\Parser.java
``` java

    private Command prepareListDate(String arguments) {
        if (arguments.isEmpty()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListDateCommand.MESSAGE_USAGE));
        }
        StringTokenizer st = new StringTokenizer(arguments.trim(), " ");
        String date = st.nextToken();
        if (!TaskDate.isValidDate(date)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListDateCommand.MESSAGE_USAGE));
        } else {
            try {
                return new ListDateCommand(new TaskDate(date));
            } catch (IllegalValueException ive) {
                return new IncorrectCommand(ive.getMessage());

            }
        }
    }

    private Command prepareListPriority(String args) {
        if (args.isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListPriorityCommand.MESSAGE_USAGE));
        }
<<<<<<< Updated upstream
        StringTokenizer st = new StringTokenizer(args.trim(), " ");
        String intValue = st.nextToken();
        if (st.hasMoreTokens()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListPriorityCommand.MESSAGE_USAGE));
        }
        if (!isInt(intValue)) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListPriorityCommand.MESSAGE_USAGE));
        }
        int targetIdx = Integer.valueOf(intValue);
        if (targetIdx < 0 || targetIdx > 3) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_TASK_DISPLAYED_INDEX, ListPriorityCommand.MESSAGE_USAGE));
        } else
            return new ListPriorityCommand(intValue);
=======

        initialiseTaskComponentArray();
        StringTokenizer st = new StringTokenizer(args.trim(), " ");
        taskComponentArray[Task.TASK_PRIORITY] = st.nextToken();

        if (st.hasMoreTokens() || !isInt(taskComponentArray[Task.TASK_PRIORITY])) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListPriorityCommand.MESSAGE_USAGE));
        }

        int targetIdx = Integer.valueOf(taskComponentArray[Task.TASK_PRIORITY]);
        if (targetIdx < Integer.valueOf(TaskPriority.DEFAULT_PRIORITY)
                || targetIdx > Integer.valueOf(TaskPriority.HIGH_PRIORITY)) {
            return new IncorrectCommand(
                    String.format(TaskPriority.MESSAGE_TASK_PRIORITY_CONSTRAINTS, ListPriorityCommand.MESSAGE_USAGE));
        } else {
            return new ListPriorityCommand(taskComponentArray[Task.TASK_PRIORITY]);
        }
>>>>>>> Stashed changes
    }

    /**
     * Parses arguments in the context of the edit command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareEdit(String args) {
<<<<<<< Updated upstream
        String description = "default";
        String startDate = TaskDate.DEFAULT_DATE;
        String endDate = TaskDate.DEFAULT_DATE;
        String startTime = TaskTime.DEFAULT_START_TIME;
        String endTime = TaskTime.DEFAULT_END_TIME;
        String taskPriority = TaskPriority.DEFAULT_PRIORITY;
        
=======
        initialiseTaskComponentArray();
        initialiseHasTaskComponentArray();
        taskComponentArray[Task.DESCRIPTION] = "default";
        ArrayList<String> argsList = tokenizeArguments(args);
>>>>>>> Stashed changes

        if (argsList.isEmpty()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
<<<<<<< Updated upstream
        StringTokenizer st = new StringTokenizer(args.trim(), " ");
        String intValue = st.nextToken();
        if (!isInt(intValue)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_TASK_DISPLAYED_INDEX, EditCommand.MESSAGE_USAGE));
        }
        int targetIdx = Integer.valueOf(intValue);
        hasChangedDescription = false;
        hasChangedStartDate = false;
        hasChangedEndDate = false;
        hasChangedStartTime = false;
        hasChangedEndTime = false;
        hasChangedPriority = false;
        boolean lastChar = false;
        if (!st.hasMoreTokens()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        while (st.hasMoreTokens()) {
            String parts = st.nextToken();
            // System.out.println("Parts is " + parts);
            if (parts.equals(DESC)) {
                if (hasChangedDescription == true) {
                    return new IncorrectCommand(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
                }
                // System.out.println("I am inside desc");
                String desc = " ";
                while (!(parts.equals(ST) || parts.equals(ET) || parts.equals(SD)
                        || parts.equals("ed") | parts.equals(P)) && st.hasMoreTokens()) {
                    desc += (parts + " ");
                    parts = st.nextToken();
                    hasChangedDescription = true;
                }
                if (!(parts.equals(ST) || parts.equals(ET) || parts.equals(SD)
                        || parts.equals("ed") | parts.equals(P))) {
                    // System.out.println("I am here to add the last is
                    // "+parts);
                    desc += parts;
                    lastChar = true;
                }
                desc = desc.trim();
                if (Description.isValidDescription(desc)) {
                    System.out.println("The new desc is valid");
                    description = desc.substring(5);
                    hasChangedDescription = true;
                }
                // System.out.println("Description End: " + desc);
            }
            if (parts.equals(ST)) {
                if (hasChangedStartTime == true) {
                    return new IncorrectCommand(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
                }
                // System.out.println("I am inside start time");
                if (st.hasMoreTokens()) {
                    String startT = st.nextToken();
                    if (TaskTime.isValidTime(startT)) {
                        startTime = startT.trim();
                        hasChangedStartTime = true;
                    } else {
                        return new IncorrectCommand(
                                String.format(MESSAGE_INVALID_COMMAND_FORMAT, TaskTime.MESSAGE_TASK_TIME_CONSTRAINTS));
                    }
=======

        String index = argsList.remove(0);
        if (!isInt(index)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_TASK_DISPLAYED_INDEX, EditCommand.MESSAGE_USAGE));
        }

        if (argsList.isEmpty()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        int targetIdx = Integer.valueOf(index);
        return splitInputWithGivenNewParameters(targetIdx, argsList);
    }

    private Command splitInputWithGivenNewParameters(int targetIdx, ArrayList<String> argsList) {
        while (!argsList.isEmpty()) {
            switch (argsList.get(0)) {
            case DESCRIPTION:
                if (hasTaskComponentArray[Task.DESCRIPTION_COMPONENT] == true) {
                    return new IncorrectCommand(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
                }
                updateDescription(argsList);
                break;

            case START_DATE:
                argsList.remove(0);

                if (hasTaskComponentArray[Task.START_DATE_COMPONENT] == true || argsList.isEmpty()) {
                    return new IncorrectCommand(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
                }
                taskComponentArray[Task.START_DATE] = argsList.remove(0);
                if (TaskDate.isValidDate(taskComponentArray[Task.START_DATE])) {
                    hasTaskComponentArray[Task.START_DATE_COMPONENT] = true;
>>>>>>> Stashed changes
                } else {
                    return new IncorrectCommand(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, TaskDate.MESSAGE_TASK_DATE_CONSTRAINTS));
                }
<<<<<<< Updated upstream
                // System.out.println("Start time is " + startTime);
            }
            if (parts.equals(ET)) {
                if (hasChangedEndTime == true) {
=======
                break;
            case END_DATE:
                argsList.remove(0);
                if (hasTaskComponentArray[Task.END_DATE_COMPONENT] == true || argsList.isEmpty()) {
>>>>>>> Stashed changes
                    return new IncorrectCommand(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
                }
                taskComponentArray[Task.END_DATE] = argsList.remove(0);
                if (TaskDate.isValidDate(taskComponentArray[Task.END_DATE])) {
                    hasTaskComponentArray[Task.END_DATE_COMPONENT] = true;
                } else {
                    return new IncorrectCommand(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, TaskDate.MESSAGE_TASK_DATE_CONSTRAINTS));
                }
<<<<<<< Updated upstream
                // System.out.println("End time is " + endTime);
            }
            if (parts.equals(SD)) {
                if (hasChangedStartDate == true) {
=======
                break;
            case START_TIME:
                argsList.remove(0);
                if (hasTaskComponentArray[Task.START_TIME_COMPONENT] == true || argsList.isEmpty()) {
>>>>>>> Stashed changes
                    return new IncorrectCommand(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
                }
                taskComponentArray[Task.START_TIME] = argsList.remove(0);
                if (TaskTime.isValidTime(taskComponentArray[Task.START_TIME])) {
                    hasTaskComponentArray[Task.START_TIME_COMPONENT] = true;
                } else {
                    return new IncorrectCommand(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, TaskTime.MESSAGE_TASK_TIME_CONSTRAINTS));
                }
<<<<<<< Updated upstream
                // System.out.println("Start Date is " + startDate);
            }
            if (parts.equals(ED)) {
                if (hasChangedEndDate == true) {
=======
                break;
            case END_TIME:
                argsList.remove(0);
                if (hasTaskComponentArray[Task.END_TIME_COMPONENT] == true || argsList.isEmpty()) {
>>>>>>> Stashed changes
                    return new IncorrectCommand(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
                }
                taskComponentArray[Task.END_TIME] = argsList.remove(0);
                if (TaskTime.isValidTime(taskComponentArray[Task.END_TIME])) {
                    hasTaskComponentArray[Task.END_TIME_COMPONENT] = true;
                } else {
                    return new IncorrectCommand(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, TaskTime.MESSAGE_TASK_TIME_CONSTRAINTS));
                }
<<<<<<< Updated upstream
                // System.out.println("End Date is " + endDate);
            }
            if (parts.equals(P)) {
                if (hasChangedPriority == true) {
=======
                break;
            case PRIORITY:
                argsList.remove(0);
                if (hasTaskComponentArray[Task.PRIORITY_COMPONENT] == true || argsList.isEmpty()) {
>>>>>>> Stashed changes
                    return new IncorrectCommand(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
                }
                taskComponentArray[Task.TASK_PRIORITY] = argsList.remove(0);
                if (TaskPriority.isValidPriority(taskComponentArray[Task.TASK_PRIORITY])) {
                    hasTaskComponentArray[Task.PRIORITY_COMPONENT] = true;
                } else {
                    return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                            TaskPriority.MESSAGE_TASK_PRIORITY_CONSTRAINTS));
                }
<<<<<<< Updated upstream
                // System.out.println("Priority is " + taskPriority);
            }
            if (!(parts.equals(DESC) || parts.equals(ST) || parts.equals(ET) || parts.equals(SD)
                    || parts.equals("ed") || parts.equals(P)) && lastChar == false) {
                // System.out.println("I am here as incrct because of parts
                // "+parts);
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
            }
        }
        // System.out
        // .println("Desc: " + hasChangedDescription + " st: " +
        // hasChangedStartTime + " et: " + hasChangedEndTime
        // + " sd: " + hasChangedStartDate + " ed: " + hasChangedEndDate + " p:
        // " + hasChangedPriority);
        try {
            // System.out.println("I am here to exectue edit command");
            return new EditCommand(targetIdx, new Description(description), hasChangedDescription,
                    new TaskDate(startDate), hasChangedStartDate, new TaskDate(endDate), hasChangedEndDate,
                    new TaskTime(startTime), hasChangedStartTime, new TaskTime(endTime), hasChangedEndTime,
                    new TaskPriority(taskPriority), hasChangedPriority);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
=======
                break;
            default:
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
            }
        }
        try {
            return new EditCommand(targetIdx, new Description(taskComponentArray[Task.DESCRIPTION]),
                    new TaskDate(taskComponentArray[Task.START_DATE]), new TaskDate(taskComponentArray[Task.END_DATE]),
                    new TaskTime(taskComponentArray[Task.START_TIME]), new TaskTime(taskComponentArray[Task.END_TIME]),
                    new TaskPriority(taskComponentArray[Task.TASK_PRIORITY]), hasTaskComponentArray);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    private void updateDescription(ArrayList<String> argsList) {
        argsList.remove(0);
        String desc = " ";
        while (!argsList.isEmpty() && !(argsList.get(0).equals(START_TIME) || argsList.get(0).equals(END_TIME)
                || argsList.get(0).equals(START_DATE) || argsList.get(0).equals(END_DATE)
                || argsList.get(0).equals(PRIORITY))) {
            desc += (argsList.remove(0) + " ");
            hasTaskComponentArray[Task.DESCRIPTION_COMPONENT] = true;
        }
        hasTaskComponentArray[Task.DESCRIPTION_COMPONENT] = true;
        taskComponentArray[Task.DESCRIPTION] = desc.trim();
>>>>>>> Stashed changes
    }

```
###### \java\seedu\taskell\logic\parser\Parser.java
``` java
=======
```
###### \java\seedu\taskell\logic\parser\Parser.java
``` java

>>>>>>> Stashed changes
    private static boolean isInt(String s) {
        try {
            int i = Integer.parseInt(s);
            return true;
        }

        catch (NumberFormatException er) {
            return false;
        }
    }

```
###### \java\seedu\taskell\model\ModelManager.java
``` java
    @Override
    public synchronized void editTask(ReadOnlyTask old, Task toEdit)
            throws DuplicateTaskException, TaskNotFoundException {
        taskManager.editTask(old, toEdit);
        indicateTaskManagerChanged();
    }
```
###### \java\seedu\taskell\model\ModelManager.java
``` java

    @Override
    public void updateFilteredtaskListDate(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new DateQualifier(keywords)));
    }

    public void updateFilteredTaskListPriority(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new PriorityQualifier(keywords)));

    } 
```
###### \java\seedu\taskell\model\ModelManager.java
``` java
    private class DateQualifier implements Qualifier {
        private Set<String> DateKeyWords;

        DateQualifier(Set<String> dateKeyWords) {
            this.DateKeyWords = dateKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            String searchString = task.getStartDate().taskDate + " " + task.getTaskType();
            return DateKeyWords.stream().allMatch(keyword -> StringUtil.containsIgnoreCase(searchString, keyword));
        }

        @Override
        public String toString() {
            return "date=" + String.join(", ", DateKeyWords);
        }
    }

    private class PriorityQualifier implements Qualifier {
        private Set<String> PriorityKeyWords;

        PriorityQualifier(Set<String> keyWords) {
            this.PriorityKeyWords = keyWords;
        }
        
        @Override
        public boolean run(ReadOnlyTask task) {
            String searchString = task.getTaskPriority().taskPriority;
            return PriorityKeyWords.stream().allMatch(keyword -> StringUtil.containsIgnoreCase(searchString, keyword));
        }


        @Override
        public String toString() {
            return "prioritye=" + String.join(", ", PriorityKeyWords);
        }

    }
```
###### \java\seedu\taskell\model\task\UniqueTaskList.java
``` java
    /**
     * Edits the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean edit(ReadOnlyTask old, Task edit) throws TaskNotFoundException {
        assert old != null;
        final boolean taskFoundAndUpdated = internalList.contains(old);
        if (!taskFoundAndUpdated) {
            throw new TaskNotFoundException();
        }
        internalList.set(internalList.indexOf(old), edit);
        return taskFoundAndUpdated;
    }
```
###### \java\seedu\taskell\model\TaskManager.java
``` java
    /**
     * Edits a task in task manager.
     *
     * @throws UniqueTaskList.DuplicateTaskException
     *             if an equivalent task already exists.
     * @throws TaskNotFoundException 
     */
    public boolean editTask(ReadOnlyTask old, Task p) throws UniqueTaskList.DuplicateTaskException, TaskNotFoundException {
        if (tasks.edit(old, p)) {
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }
```
