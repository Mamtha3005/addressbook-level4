# A0142130A
###### \java\seedu\taskell\commons\events\storage\StorageLocationChangedEvent.java
``` java
package seedu.taskell.commons.events.storage;

import seedu.taskell.commons.core.Config;
import seedu.taskell.commons.events.BaseEvent;

public class StorageLocationChangedEvent extends BaseEvent {
    
    private Config config;
    
    public StorageLocationChangedEvent(Config config) {
        this.config = config;
    }
    
    public Config getConfig() {
        return config;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\taskell\commons\events\ui\DisplayCalendarViewEvent.java
``` java
package seedu.taskell.commons.events.ui;

import seedu.taskell.commons.events.BaseEvent;

/** Indicates display panel needs to show calendar **/

public class DisplayCalendarViewEvent extends BaseEvent {
   
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\taskell\commons\events\ui\DisplayListChangedEvent.java
``` java
package seedu.taskell.commons.events.ui;

import java.util.ArrayList;

import seedu.taskell.commons.events.BaseEvent;

/** Indicates a list needs to be displayed on Display Panel
 * */
public class DisplayListChangedEvent extends BaseEvent {
    
    private ArrayList<String> list;
    
    public DisplayListChangedEvent(ArrayList<String> list) {
        this.list = list;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
    
    public ArrayList<String> getList() {
        return list;
    }

}
```
###### \java\seedu\taskell\logic\commands\FindCommand.java
``` java
package seedu.taskell.logic.commands;

import java.util.Set;

/**
 * Finds and lists all tasks in task manager whose description and tags contains all of the argument keywords.
 * Keyword matching is not case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose description contains all of "
            + "the specified keywords (not case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " milk bananas chicken";

    private final Set<String> keywords;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(keywords);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### \java\seedu\taskell\logic\commands\FindTagCommand.java
``` java
package seedu.taskell.logic.commands;

import java.util.Set;

/**
 * Finds and lists all tasks in task manager whose description contains any of the argument keywords.
 * Keyword matching is not case sensitive.
 */

public class FindTagCommand extends Command {

    public static final String COMMAND_WORD = "find-tag";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose description contain any of "
            + "the specified keywords (not case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " help study homework";

    private final Set<String> keywords;

    public FindTagCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskListByAnyKeyword(keywords);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }
}
```
###### \java\seedu\taskell\logic\commands\ListUndoCommand.java
``` java
package seedu.taskell.logic.commands;

import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.events.ui.DisplayListChangedEvent;

/** Lists a list of previous commands available for Undo operation
 * */
public class ListUndoCommand extends Command {
    
    public static final String COMMAND_WORD = "list-undo";

    public static final String MESSAGE_SUCCESS = "Listed all commands available for undo.";
    
    private static ListUndoCommand self;
    
    public static ListUndoCommand getInstance() {
    	if (self == null) {
    		self = new ListUndoCommand();
    	}
    	
    	return self;
    }

    @Override
    public CommandResult execute() {
        indicateDisplayListChanged();
        return new CommandResult(MESSAGE_SUCCESS);
    }

    public void indicateDisplayListChanged() {
        EventsCenter.getInstance().post(
                new DisplayListChangedEvent(UndoCommand.getListOfCommandHistoryText()));
    }

}
```
###### \java\seedu\taskell\logic\commands\SaveStorageLocationCommand.java
``` java
package seedu.taskell.logic.commands;

import java.io.IOException;
import java.util.logging.Logger;

import seedu.taskell.commons.core.Config;
import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.core.LogsCenter;
import seedu.taskell.commons.events.storage.StorageLocationChangedEvent;
import seedu.taskell.model.ReadOnlyTaskManager;
import seedu.taskell.storage.JsonConfigStorage;
import seedu.taskell.storage.Storage;

/** Saves current data file to new filepath.
 * */

public class SaveStorageLocationCommand extends Command {
    
    private Logger logger = LogsCenter.getLogger(SaveStorageLocationCommand.class.getName());
    
    public static final String COMMAND_WORD = "save";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Saves data file to new location specified. "
            + "New files can be auto-created as long as given directory is valid.\n"
            + "Parameters: FILEPATH (must be valid)\n"
            + "Example: " + COMMAND_WORD + " C:/Users/chicken/Desktop/cat";
    
    private static final String MESSAGE_SUCCESS = "Data successfully saved to new location.";
    private static final String MESSAGE_INVALID_PATH = "Filepath given is invalid. Filepath will be reset to old path.";
    
    private static Config config;
    private String newStorageFilePath, oldStorageFilePath;
    private ReadOnlyTaskManager taskManager;
    private static JsonConfigStorage jsonConfigStorage;
    private static Storage storage;
    
    public SaveStorageLocationCommand(String newStorageFilePath) {
        this.oldStorageFilePath = config.getTaskManagerFilePath();
        logger.info("Old file path: " + oldStorageFilePath);
        
        this.newStorageFilePath = newStorageFilePath.trim().replace("\\", "/") + "/taskmanager.xml";
        logger.info("New file path: " + this.newStorageFilePath);
        jsonConfigStorage = new JsonConfigStorage(Config.DEFAULT_CONFIG_FILE);
    }
    
    public static void setConfig(Config c) {
        config = c;
    }
    
    public static void setStorage(Storage s) {
        storage = s;
    }

    @Override
    public CommandResult execute() {
        assert config != null;
        assert jsonConfigStorage != null;

        taskManager = model.getTaskManager();
        
        config.setTaskManagerFilePath(newStorageFilePath);
        indicateStorageLocationChanged();
        try {
            storage.saveTaskManager(taskManager, newStorageFilePath);
        } catch (IOException e) {
            handleInvalidFilePathException();
            return new CommandResult(MESSAGE_INVALID_PATH);
        }
        
        saveToConfigJson();
        model.updateFilteredListToShowAll();
        return new CommandResult(MESSAGE_SUCCESS);
    }

    private void indicateStorageLocationChanged() {
        assert config != null;
        EventsCenter.getInstance().post(new StorageLocationChangedEvent(config));
    }
    
    private void handleInvalidFilePathException() {
        logger.info("Error writing to filepath. Handling data save exception.");
        assert config != null;
        
        config.setTaskManagerFilePath(oldStorageFilePath);  //set back to old filepath
        indicateStorageLocationChanged();
        
        try {
            storage.saveTaskManager(taskManager, newStorageFilePath);
        } catch (IOException e) {
            logger.severe("Error saving task manager");
        }
        
        saveToConfigJson();
    }
    
    private void saveToConfigJson() {
        try {
            jsonConfigStorage.saveConfigFile(config);
        } catch (IOException e) {
            logger.severe("save to config json error");
        }
    }

}
```
###### \java\seedu\taskell\logic\commands\UndoCommand.java
``` java
package seedu.taskell.logic.commands;

import java.util.ArrayList;
import java.util.logging.Logger;

import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.core.LogsCenter;
import seedu.taskell.commons.events.ui.DisplayListChangedEvent;
import seedu.taskell.model.CommandHistory;
import seedu.taskell.model.Model;
import seedu.taskell.model.task.Task;
import seedu.taskell.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.taskell.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Undo previously executed command (add or delete only for now)
 * Note: only for current session only (meaning after app is closed, history will be cleared)
 */
public class UndoCommand extends Command {
    private static final Logger logger = LogsCenter.getLogger(UndoCommand.class.getName());
    
    public static final String COMMAND_WORD = "undo";
    public static final String EDIT = "edit";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undo a previously executed command.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 3";
    
    private static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task: %1$s";
    private static final String MESSAGE_ADD_TASK_SUCCESS = "Task added back: %1$s";
    private static final String MESSAGE_EDIT_TASK_SUCCESS = "Task edited back to old version: %1$s";
    
    private static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager";
    private static final String MESSAGE_NO_TASK_TO_UNDO = "No add or delete commands available to undo.";
    private static final String MESSAGE_COMMAND_HISTORY_EMPTY = "No command history available for undo.";
    private static final String MESSAGE_INVALID_INDEX = "Index is invalid";
    
    private static ArrayList<CommandHistory> commandHistoryList;
    private static UndoCommand self;
    
    private int index;
    private CommandHistory commandHistory;
    
    public UndoCommand(int index) {
        logger.info("Creating UndoCommand with index: " + index);
        this.index = index;
    }
    
    public static UndoCommand getInstance() {
        if (self == null) {
            self = new UndoCommand(0);
        }
        
        return self;
    }

    public static ArrayList<String> getListOfCommandHistoryText() {
        assert commandHistoryList != null;
        
        UndoCommand.getInstance().updateCommandList();
        
        ArrayList<String> list = new ArrayList<>();
        for (CommandHistory history: commandHistoryList) {
            list.add(history.getCommandText());
        }
        
        return list;
    }

    //removes commandHistory with tasks not present in system
    private void updateCommandList() {
        if (model == null) {
            logger.severe("model is null");
            return;
        }
        for (CommandHistory commandHistory: commandHistoryList) {
            if (isCommandTypeAddOrEdit(commandHistory) 
                    && !model.isTaskPresent(commandHistory.getTask())) {
                commandHistoryList.remove(commandHistory);
            } else if (isUndoEditCommand(commandHistory) 
                    && !model.isTaskPresent(commandHistory.getOldTask())) {
                commandHistoryList.remove(commandHistory);
            }
        }
        
    }

    private boolean isCommandTypeAddOrEdit(CommandHistory commandHistory) {
        return (commandHistory.getCommandType().contains(AddCommand.COMMAND_WORD) 
                || commandHistory.getCommandType().contains(EDIT)) 
                && !commandHistory.isRedoTrue();
    }
    
    private boolean isUndoEditCommand(CommandHistory commandHistory) {
        return commandHistory.isRedoTrue() 
                && commandHistory.getCommandType().contains(EDIT);
    }

    @Override
    public CommandResult execute() {
        
        if (commandHistoryList.isEmpty()) {
            return new CommandResult(String.format(MESSAGE_COMMAND_HISTORY_EMPTY));
        } else if (index > commandHistoryList.size()) {
            return new CommandResult(String.format(MESSAGE_INVALID_INDEX));
        }
        
        commandHistory = commandHistoryList.get(getOffset(index));
        
        if (commandHistory.isRedoTrue()) {
            return redoUndo();
        }
        
        switch (commandHistory.getCommandType()) {
        case AddCommand.COMMAND_WORD:
            return undoAdd();
        case DeleteCommand.COMMAND_WORD:
            return undoDelete();
        case EditStartDateCommand.COMMAND_WORD: 
            return undoEdit();
        case EditEndDateCommand.COMMAND_WORD: 
            return undoEdit();
        case EditDescriptionCommand.COMMAND_WORD_1:
            return undoEdit();
        case EditDescriptionCommand.COMMAND_WORD_2:
            return undoEdit();
        case EditStartTimeCommand.COMMAND_WORD:
            return undoEdit();
        case EditEndTimeCommand.COMMAND_WORD:
            return undoEdit();
        case EditPriorityCommand.COMMAND_WORD:
            return undoEdit();
        default:
            logger.severe("CommandHistory is invalid");
            return new CommandResult(String.format(MESSAGE_NO_TASK_TO_UNDO));
        }
    }

    private CommandResult redoUndo() {
        switch (commandHistory.getCommandType()) {
        case AddCommand.COMMAND_WORD:
            return undoDelete();
        case DeleteCommand.COMMAND_WORD:
            return undoAdd();
        case EditStartDateCommand.COMMAND_WORD: 
            return redoEdit();
        case EditEndDateCommand.COMMAND_WORD: 
            return redoEdit();
        case EditDescriptionCommand.COMMAND_WORD_1:
            return redoEdit();
        case EditDescriptionCommand.COMMAND_WORD_2:
            return redoEdit();
        case EditStartTimeCommand.COMMAND_WORD:
            return redoEdit();
        case EditEndTimeCommand.COMMAND_WORD:
            return redoEdit();
        case EditPriorityCommand.COMMAND_WORD:
            return redoEdit();
        default:
            logger.severe("CommandHistory is invalid");
            return new CommandResult(String.format(MESSAGE_NO_TASK_TO_UNDO));
        }
    }

    private CommandResult undoEdit() {
        try {
            model.editTask(commandHistory.getTask(), commandHistory.getOldTask());
            deleteCommandHistory();
            addUndoCommand(commandHistory);
            indicateDisplayListChanged();
            return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, commandHistory.getOldTask()));
        } catch (DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }
        
        assert false: "Undo edit should return a command result";
        return null;
    }
    
    private CommandResult redoEdit() {
        try {
            model.editTask(commandHistory.getOldTask(), commandHistory.getTask());
            deleteCommandHistory();
            indicateDisplayListChanged();
            return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, commandHistory.getTask()));
        } catch (DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }
        
        assert false: "Redo edit should return a command result";
        return null;
    }

    private CommandResult undoDelete() {
        try {
            model.addTask(commandHistory.getTask());
            deleteCommandHistory();
            addUndoCommand(commandHistory);
            indicateDisplayListChanged();
            return new CommandResult(String.format(MESSAGE_ADD_TASK_SUCCESS, commandHistory.getTask()));
        } catch (DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }
    }

    private CommandResult undoAdd() {
        try {
            model.deleteTask(commandHistory.getTask());
            deleteCommandHistory();
            addUndoCommand(commandHistory);
            indicateDisplayListChanged();
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }
        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, commandHistory.getTask()));
    }

    private void deleteCommandHistory() {
        commandHistoryList.remove(commandHistory);
    }
    
    private void addUndoCommand(CommandHistory commandHistory) {
        if (commandHistory.isRedoTrue()) {
            return;
        }
        commandHistory.setCommandText("undo " + commandHistory.getCommandText());
        commandHistory.setToRedoToTrue();
        commandHistoryList.add(commandHistory);
    }
    
    /******** static methods *********/
    
    public static void initializeCommandHistory() {
        if (commandHistoryList == null) {
            commandHistoryList = new ArrayList<>();
        }
    }
    
    public static void clearCommandHistory() {
        commandHistoryList.clear();
    }
    
    private static int getOffset(int index) {
        return index - 1;
    }
    
    public static void addCommandToHistory(String commandText, 
            String commandType) {
        assert commandHistoryList != null;
        commandHistoryList.add(new CommandHistory(commandText, commandType));
    }
    
    public static void addTaskToCommandHistory(Task task) {
        logger.info("Adding task to history");
        if (commandHistoryList.isEmpty()) {
            logger.warning("No command history to add task to");
            return;
        }
        
        commandHistoryList.get(getOffset(commandHistoryList.size())).setTask(task);
    }
    
    public static void addOldTaskToCommandHistory(Task task) {
        logger.info("Adding old task to history");
        if (commandHistoryList.isEmpty()) {
            logger.warning("No command history to add task to");
            return;
        }
        
        commandHistoryList.get(getOffset(commandHistoryList.size())).setOldTask(task);
    }

    public static void deletePreviousCommand() {
        logger.info("Command unsuccessfully executed. Deleting command history.");
        if (commandHistoryList.isEmpty()) {
            logger.warning("No command history to delete");
            return;
        }
        commandHistoryList.remove(getOffset(commandHistoryList.size()));
    }

    /****** Event ******/
    public void indicateDisplayListChanged() {
        EventsCenter.getInstance().post(
                new DisplayListChangedEvent(getListOfCommandHistoryText()));
    }
}
```
###### \java\seedu\taskell\logic\commands\ViewCalendarCommand.java
``` java
package seedu.taskell.logic.commands;

import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.events.ui.DisplayCalendarViewEvent;

/** Shows calendar view on right panel
 * */
public class ViewCalendarCommand extends Command {
    
    public static final String COMMAND_WORD_1 = "calendar";
    public static final String COMMAND_WORD_2 = "cal";
    
    private static final String MESSAGE_SUCCESS = "Displayed calendar.";

    @Override
    public CommandResult execute() {
        indicateDisplayCalendarView();
        return new CommandResult(String.format(MESSAGE_SUCCESS));
    }
    
    private void indicateDisplayCalendarView() {
        EventsCenter.getInstance().post(new DisplayCalendarViewEvent());
    }

}
```
###### \java\seedu\taskell\logic\parser\Parser.java
``` java

    /**
     * Parses arguments in the context of undo command.
     * 
     */
    private Command prepareUndo(String args) {
        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoCommand.MESSAGE_USAGE));
        }
        return new UndoCommand(index.get());
    }

    /**
     * Parses arguments in the context of the find task by tags command.
     * 
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareFindByTag(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindTagCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindTagCommand(keywordSet);

    }

    /**
     * Parses arguments in the context of the save storage location command.
     * 
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareSaveStorageLocation(String args) {
        if (args.isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SaveStorageLocationCommand.MESSAGE_USAGE));
        }
        return new SaveStorageLocationCommand(args);
    }
```
###### \java\seedu\taskell\MainApp.java
``` java
    @Subscribe
    private void handleStorageLocationChangedEvent(StorageLocationChangedEvent event) {
        config = event.getConfig();
        storage = new StorageManager(config.getTaskManagerFilePath(), config.getUserPrefsFilePath());
    }
```
###### \java\seedu\taskell\model\CommandHistory.java
``` java
package seedu.taskell.model;

import seedu.taskell.model.task.Task;

/** Stores the relevant details of a command so it can be undone via UndoCommand
 *  each Add/Delete/Edit Command executed should correspond to a CommandHistory 
 *  stored in UndoCommand's list of CommandHistory
 * */
public class CommandHistory {
    private String commandText, commandType;
    private Task task;      //relevent task to be added, deleted or edited
    private Task oldTask;   //oldTask needed for EditCommands
    private boolean toRedo;
    
    public CommandHistory() {
        commandText = "default command text";
        commandType = "default command type";
        task = null;
        toRedo = false;
    }
    
    public CommandHistory(String commandText, String commandType) {
        assert commandText != null;
        assert commandType != null;
        assert !commandText.trim().isEmpty();
        assert !commandType.trim().isEmpty();
        
        this.commandText = commandText.trim();
        this.commandType = commandType.trim();
        this.task = null;
        toRedo = false;
    }
    
    public String getCommandText() {
        return commandText;
    }
    
    public String getCommandType() {
        return commandType;
    }
    
    public Task getTask() {
        return task;
    }
    
    public Task getOldTask() {
        return oldTask;
    }
    
    public boolean isRedoTrue() {
        return toRedo;
    }
    
    /**** Setter methods ****/
    
    public void setCommandText(String text) {
        this.commandText = text;
    }
    
    public void setTask(Task task) {
        assert task != null;
        this.task = task;
        if (commandType.equals("delete")) {
            commandText = "delete " + this.task.getAsText();
        }
    }
    
    public void setOldTask(Task task) {
        this.oldTask = task;
    }
    
    public void setToRedoToTrue() {
        toRedo = true;
    }
    
}
```
###### \java\seedu\taskell\model\ModelManager.java
``` java
    @Override
    public void updateFilteredTaskListByAnyKeyword(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new TagsQualifier(keywords)));
    }

```
###### \java\seedu\taskell\model\ModelManager.java
``` java
        @Override
        public boolean run(ReadOnlyTask task) {
            String searchString = task.getDescription().description + " " + task.tagsSimpleString();
            return nameKeyWords.stream().allMatch(keyword -> StringUtil.containsIgnoreCase(searchString, keyword));
        }

```
###### \java\seedu\taskell\model\ModelManager.java
``` java
    private class TagsQualifier implements Qualifier {
        private Set<String> tagsKeyWords;

        TagsQualifier(Set<String> keyWords) {
            this.tagsKeyWords = keyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return tagsKeyWords.stream()
                    .filter(keyword -> StringUtil.containsIgnoreCase(task.tagsSimpleString(), keyword)).findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", tagsKeyWords);
        }
    }

```
###### \java\seedu\taskell\storage\JsonConfigStorage.java
``` java
package seedu.taskell.storage;

import java.io.File;
import java.io.IOException;
import java.util.Optional;
import java.util.logging.Logger;

import seedu.taskell.commons.core.Config;
import seedu.taskell.commons.core.LogsCenter;
import seedu.taskell.commons.exceptions.DataConversionException;
import seedu.taskell.commons.util.FileUtil;

/**
 * A class to access Config stored in the hard disk as a json file
 */

public class JsonConfigStorage implements ConfigStorage {

    private static final Logger logger = LogsCenter.getLogger(JsonConfigStorage.class);
    
    private String filePath;
    
    public JsonConfigStorage(String filePath) {
        this.filePath = filePath;
    }
    
    @Override
    public Optional<Config> readConfigFile() throws DataConversionException, IOException {
        return readConfig(filePath);
    }

    @Override
    public void saveConfigFile(Config config) throws IOException {
        saveConfig(config, filePath);
    }
    
    /**
     * Similar to {@link #readConfigFile()}
     * @param configFilePath location of the data. Cannot be null.
     * @throws DataConversionException if the file format is not as expected.
     */
    public Optional<Config> readConfig(String configFilePath) throws DataConversionException {
        assert configFilePath != null;

        File configFile = new File(configFilePath);

        if (!configFile.exists()) {
            logger.info("Config file "  + configFile + " not found");
            return Optional.empty();
        }

        Config config;

        try {
            config = FileUtil.deserializeObjectFromJsonFile(configFile, Config.class);
        } catch (IOException e) {
            logger.warning("Error reading from config file " + configFile + ": " + e);
            throw new DataConversionException(e);
        }

        return Optional.of(config);
    }

    /**
     * Similar to {@link #saveConfigFile(Config)}
     * @param configFilePath location of the data. Cannot be null.
     */
    private void saveConfig(Config config, String configFilePath) throws IOException {
        assert config != null;
        assert configFilePath != null;
        assert !configFilePath.isEmpty();

        FileUtil.serializeObjectToJsonFile(new File(configFilePath), config);
    }

}
```
###### \java\seedu\taskell\ui\CalendarView.java
``` java
package seedu.taskell.ui;

import jfxtras.scene.control.agenda.Agenda;

/** This class holds the necessary elements to display calendar UI via Agenda API from jfxtras
 * */

public class CalendarView {
    
    private Agenda agenda;
    
    public CalendarView() {
        agenda = new Agenda();
    }
    
    public Agenda getAgenda() {
        return agenda;
    }

}
```
###### \java\seedu\taskell\ui\DisplayPanel.java
``` java
package seedu.taskell.ui;

import javafx.scene.Node;
import javafx.scene.control.TextArea;
import javafx.scene.layout.AnchorPane;
import jfxtras.scene.control.agenda.Agenda;
import seedu.taskell.commons.core.LogsCenter;
import seedu.taskell.commons.util.FxViewUtil;

import java.util.ArrayList;
import java.util.logging.Logger;

/**
 * The Display Panel of the App.
 */
public class DisplayPanel extends UiPart{

    private static Logger logger = LogsCenter.getLogger(DisplayPanel.class);
    
    public static final String RESULT_DISPLAY_ID = "resultDisplay";
    private static final String STATUS_BAR_STYLE_SHEET = "result-display";
    
    private TextArea display;
    private CalendarView calendarView;

    /**
     * Constructor is kept private as {@link #load(AnchorPane)} is the only way to create a DisplayPanel.
     */
    private DisplayPanel() {
        calendarView = new CalendarView();
        display = new TextArea();
    }

    @Override
    public void setNode(Node node) {
        //not applicable
    }

    @Override
    public String getFxmlPath() {
        return null; //not applicable
    }

    /**
     * This method should be called after the FX runtime is initialized and in FX application thread.
     * @param placeholder The AnchorPane where the DisplayPanel must be inserted
     */
    public static DisplayPanel load(AnchorPane placeholder){
        logger.info("Initializing display panel");
        DisplayPanel displayPanel = new DisplayPanel();
        
        //displayPanel.display = new TextArea();
        displayPanel.display.setEditable(false);
        displayPanel.display.setId(RESULT_DISPLAY_ID);
        displayPanel.display.getStyleClass().removeAll();
        displayPanel.display.getStyleClass().add(STATUS_BAR_STYLE_SHEET);
        
        FxViewUtil.applyAnchorBoundaryParameters(displayPanel.display, 0.0, 0.0, 0.0, 0.0);
        placeholder.getChildren().add(displayPanel.display);
        
        displayPanel.display.setText("Welcome to Taskell!\n"
                + "Enter 'add' in command box to add a task.\n"
                + "Enter 'list-undo' for list of commands to undo.\n"
                + "Enter 'help' for more information about commands.\n"
                + "Enter 'calendar' to view calendar.");
       
        return displayPanel;
    }
    
    public void loadList(AnchorPane placeholder, ArrayList<String> list) {
        placeholder.getChildren().clear();
        placeholder.getChildren().add(display);
        
        display.setText("");
        if (list.isEmpty()) {
            display.setText("No commands available for undo.");
        }
        else {
            for (int i=0; i<list.size(); i++) {
                int index = i+1;
                display.appendText(index + ". " + list.get(i) + "\n");
            }
        }
    }
    
    public void loadCalendar(AnchorPane placeholder) {
        placeholder.getChildren().clear();
        
        Agenda agenda = calendarView.getAgenda();
        
        FxViewUtil.applyAnchorBoundaryParameters(agenda, 0.0, 0.0, 0.0, 0.0);
        
        placeholder.getChildren().add(agenda);
    }
    
```
###### \java\seedu\taskell\ui\MainWindow.java
``` java
    
    public void loadList(ArrayList<String> list) {
        displayPanel.loadList(displayPanelPlaceholder, list);
    }
    
    public void loadCalendarView() {
        displayPanel.loadCalendar(displayPanelPlaceholder);
    }
    
```
###### \java\seedu\taskell\ui\UiManager.java
``` java
    
    @Subscribe
    private void handleDisplayList(DisplayListChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        logger.info("Displaying list...");
        mainWindow.loadList(event.getList());
    }
    
    @Subscribe
    private void handleShowCalendarView(DisplayCalendarViewEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        logger.info("Displaying calendar view...");
        mainWindow.loadCalendarView();
    }
    
```
