# A0142130A
###### \java\seedu\taskell\commons\events\storage\StorageLocationChangedEvent.java
``` java
package seedu.taskell.commons.events.storage;

import seedu.taskell.commons.core.Config;
import seedu.taskell.commons.events.BaseEvent;

/**
 * Indicates storage location has changed.
 */
public class StorageLocationChangedEvent extends BaseEvent {
    
    private Config config;
    
    public StorageLocationChangedEvent(Config config) {
        this.config = config;
    }
    
    public Config getConfig() {
        return config;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\taskell\commons\events\ui\ClearCommandInputEvent.java
``` java
package seedu.taskell.commons.events.ui;

import seedu.taskell.commons.events.BaseEvent;

/** indicates ClearCommand is being executed
 * */

public class ClearCommandInputEvent extends BaseEvent {

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\taskell\commons\events\ui\DisplayCalendarViewEvent.java
``` java
package seedu.taskell.commons.events.ui;

import seedu.taskell.commons.events.BaseEvent;

/** Indicates display panel needs to show calendar **/

public class DisplayCalendarViewEvent extends BaseEvent {
   
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\taskell\commons\events\ui\DisplayListChangedEvent.java
``` java
package seedu.taskell.commons.events.ui;

import java.util.ArrayList;

import seedu.taskell.commons.events.BaseEvent;

/** Indicates a list needs to be displayed on Display Panel
 * */
public class DisplayListChangedEvent extends BaseEvent {
    
    private ArrayList<String> list;
    
    public DisplayListChangedEvent(ArrayList<String> list) {
        this.list = list;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
    
    public ArrayList<String> getList() {
        return list;
    }

}
```
###### \java\seedu\taskell\commons\events\undo\ExecutedIncorrectCommandEvent.java
``` java
package seedu.taskell.commons.events.undo;

import seedu.taskell.commons.events.BaseEvent;

/** Indicates a Command has been entered incorrectly, to feedback to History
 *  NOTE: this is different from IncorrectCommandAttemptedEvent (which is meant for UI)
 */

public class ExecutedIncorrectCommandEvent extends BaseEvent {
    
    private boolean isUndoableCommand;
    
    public ExecutedIncorrectCommandEvent(boolean isUndoableCommand) {
        this.isUndoableCommand = isUndoableCommand;
    }
    
    public boolean isUndoableCommand() {
        return isUndoableCommand;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\taskell\logic\commands\ClearCommand.java
``` java
package seedu.taskell.logic.commands;

import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.events.ui.ClearCommandInputEvent;
import seedu.taskell.model.TaskManager;

/**
 * Clears the task manager. Will show confirm dialog.
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = "clear";
    public static final String MESSAGE_SUCCESS = "Clear command executed.";
    private static ClearCommand self;
    private static boolean isUnderTesting;  //for testing ONLY

    public ClearCommand() {}

    public static ClearCommand getInstance() {
        if (self == null) {
            self = new ClearCommand();
        }
        
        return self;
    }
    
    /** if set to true, ClearCommand bypasses confirm dialog
     *  for running test cases ONLY
     * */
    public static void setIsUnderTesting(boolean value) {
        isUnderTesting = value;
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        
        if (isUnderTesting) {
            executeClear();
        } else {
            raiseClearCommandInputEvent();
        }
        
        return new CommandResult(MESSAGE_SUCCESS);
    }
    
    /** executes reset data
     *  will be called from UiManager after confirmation of clear
     * */
    public void executeClear() {
        model.resetData(TaskManager.getEmptyTaskManager());
    }

    private void raiseClearCommandInputEvent() {
        EventsCenter.getInstance().post(new ClearCommandInputEvent());      
    }
    
```
###### \java\seedu\taskell\logic\commands\FindCommand.java
``` java
package seedu.taskell.logic.commands;

import java.util.Set;

/**
 * Finds and lists all tasks in task manager whose description and tags contains all of the argument keywords.
 * Keyword matching is not case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose description contains all of "
            + "the specified keywords (not case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " milk bananas chicken";

    private final Set<String> keywords;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(keywords);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### \java\seedu\taskell\logic\commands\FindTagCommand.java
``` java
package seedu.taskell.logic.commands;

import java.util.Set;

/**
 * Finds and lists all tasks in task manager whose description contains any of the argument keywords.
 * Keyword matching is not case sensitive.
 */

public class FindTagCommand extends Command {

    public static final String COMMAND_WORD = "find-tag";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose description contain any of "
            + "the specified keywords (not case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " help study homework";

    private final Set<String> keywords;

    public FindTagCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskListByAnyKeyword(keywords);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }
}
```
###### \java\seedu\taskell\logic\commands\IncorrectCommand.java
``` java
    
    /** for setting latest command as an undoable command
     * */
    public static void setIsUndoableCommand(boolean value) {
        isAddEditDeleteCommand = value;
    }
    
    public static boolean isUndoableCommand() {
        return isAddEditDeleteCommand;
    }
    
    /** if latest command is an undoable command, need to delete its command history
     * */
    private void indicateExecutedIncorrectCommand() {
        EventsCenter.getInstance().post(new ExecutedIncorrectCommandEvent(isAddEditDeleteCommand));
    }

```
###### \java\seedu\taskell\logic\commands\SaveStorageLocationCommand.java
``` java
package seedu.taskell.logic.commands;

import java.io.IOException;
import java.util.logging.Logger;

import seedu.taskell.commons.core.Config;
import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.core.LogsCenter;
import seedu.taskell.commons.events.storage.StorageLocationChangedEvent;
import seedu.taskell.commons.exceptions.DataConversionException;
import seedu.taskell.model.ReadOnlyTaskManager;
import seedu.taskell.model.task.Task;
import seedu.taskell.storage.JsonConfigStorage;
import seedu.taskell.storage.Storage;

/** Saves current data file to new filepath.
 * */

public class SaveStorageLocationCommand extends Command {
    
    private Logger logger = LogsCenter.getLogger(SaveStorageLocationCommand.class.getName());
    
    public static final String COMMAND_WORD = "save";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Saves data file to new location specified. "
            + "New files can be auto-created as long as given directory is valid.\n"
            + "Parameters: FILEPATH (must be valid)\n"
            + "Example: " + COMMAND_WORD + " C:\\Users\\chicken\\Desktop\\cat";
    
    private static final String MESSAGE_SUCCESS = "Data successfully saved to new location.";
    private static final String MESSAGE_INVALID_PATH = "Filepath given is invalid. Filepath will be reset to old path.";
    
    private static Config config;
    private String newStorageFilePath, oldStorageFilePath;
    private ReadOnlyTaskManager taskManager;
    private static JsonConfigStorage jsonConfigStorage;
    private static Storage storage;
    
    public SaveStorageLocationCommand(String newStorageFilePath) {
        this.oldStorageFilePath = config.getTaskManagerFilePath();
        logger.info("Old file path: " + oldStorageFilePath);
        
        this.newStorageFilePath = newStorageFilePath.trim().replace("\\", "/") + "/taskmanager.xml";
        logger.info("New file path: " + this.newStorageFilePath);
        jsonConfigStorage = new JsonConfigStorage(Config.DEFAULT_CONFIG_FILE);
    }
    
    public static void setConfig(Config c) {
        config = c;
    }
    
    public static void setStorage(Storage s) {
        storage = s;
    }

    @Override
    public CommandResult execute() {
        assert config != null;
        assert jsonConfigStorage != null;

        taskManager = model.getTaskManager();
        
        config.setTaskManagerFilePath(newStorageFilePath);
        indicateStorageLocationChanged();
        try {
            storage.saveTaskManager(taskManager, newStorageFilePath);
            storage.readTaskManager();
        } catch (IOException e) {
            handleInvalidFilePathException();
            return new CommandResult(MESSAGE_INVALID_PATH);
        } catch (DataConversionException e) {
            handleInvalidFilePathException();
            return new CommandResult(MESSAGE_INVALID_PATH);
        }
        
        saveToConfigJson();
        model.updateFilteredListToShowAll();
        return new CommandResult(MESSAGE_SUCCESS);
    }

    private void indicateStorageLocationChanged() {
        assert config != null;
        EventsCenter.getInstance().post(new StorageLocationChangedEvent(config));
    }
    
    private void handleInvalidFilePathException() {
        logger.info("Error writing to filepath. Handling data save exception.");
        assert config != null;
        
        config.setTaskManagerFilePath(oldStorageFilePath);  //set back to old filepath
        indicateStorageLocationChanged();
        
        try {
            storage.saveTaskManager(taskManager, newStorageFilePath);
        } catch (IOException e) {
            logger.severe("Error saving task manager");
        }
        
        saveToConfigJson();
    }
    
    private void saveToConfigJson() {
        try {
            jsonConfigStorage.saveConfigFile(config);
        } catch (IOException e) {
            logger.severe("save to config json error");
        }
    }

}
```
###### \java\seedu\taskell\logic\commands\UndoCommand.java
``` java
package seedu.taskell.logic.commands;

import java.util.ArrayList;
import java.util.logging.Logger;

import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.core.LogsCenter;
import seedu.taskell.commons.events.ui.DisplayListChangedEvent;
import seedu.taskell.history.CommandHistory;
import seedu.taskell.history.History;
import seedu.taskell.history.HistoryManager;
import seedu.taskell.model.Model;
import seedu.taskell.model.task.Task;
import seedu.taskell.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.taskell.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Undo previously executed commands (add, delete, edit)
 * Note: only for current session only (meaning after app is closed, history will be cleared)
 */
public class UndoCommand extends Command {
    private static final Logger logger = LogsCenter.getLogger(UndoCommand.class.getName());
    
    public static final String COMMAND_WORD = "undo";
    public static final String EDIT = "edit";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undo a previously executed command.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 3";
    
    private static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task: %1$s";
    private static final String MESSAGE_ADD_TASK_SUCCESS = "Task added back: %1$s";
    private static final String MESSAGE_EDIT_TASK_SUCCESS = "Task edited back to old version: %1$s";
    
    private static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager";
    private static final String MESSAGE_NO_TASK_TO_UNDO = "No add or delete commands available to undo.";
    private static final String MESSAGE_COMMAND_HISTORY_EMPTY = "No command history available for undo.";
    private static final String MESSAGE_INVALID_INDEX = "Index is invalid";
    
    private ArrayList<CommandHistory> commandHistoryList;
    private History history;
    
    private int index;
    private CommandHistory commandHistory;
    
    public UndoCommand(int index) {
        logger.info("Creating UndoCommand with index: " + index);
        
        history = HistoryManager.getInstance();
        commandHistoryList = history.getList();
        this.index = index;
    }

    public UndoCommand() {
        logger.info("Creating UndoCommand without index");
        
        history = HistoryManager.getInstance();
        commandHistoryList = history.getList();
        this.index = commandHistoryList.size(); //offset will be done in execute()
    }

    @Override
    public CommandResult execute() {
        
        if (commandHistoryList.isEmpty()) {
            return new CommandResult(String.format(MESSAGE_COMMAND_HISTORY_EMPTY));
        } else if (index > commandHistoryList.size()) {
            return new CommandResult(String.format(MESSAGE_INVALID_INDEX));
        }
        
        commandHistory = commandHistoryList.get(getOffset(index));
        
        if (commandHistory.isRedoTrue()) {
            return redoUndo();
        }
        
        String commandType = commandHistory.getCommandType();
        if (commandType.equals(AddCommand.COMMAND_WORD)) {
            return undoAdd();
        } else if (commandType.equals(DeleteCommand.COMMAND_WORD)) {
            return undoDelete();
        } else if (commandType.contains(EDIT)) {
            return undoEdit();
        } else {
            logger.severe("CommandHistory is invalid");
            return new CommandResult(String.format(MESSAGE_NO_TASK_TO_UNDO));
        }
        
    }

    private CommandResult redoUndo() {
        
        String commandType = commandHistory.getCommandType();
        if (commandType.equals(AddCommand.COMMAND_WORD)) {
            return undoDelete();
        } else if (commandType.equals(DeleteCommand.COMMAND_WORD)) {
            return undoAdd();
        } else if (commandType.contains(EDIT)) {
            return redoEdit();
        } else {
            logger.severe("CommandHistory is invalid");
            return new CommandResult(String.format(MESSAGE_NO_TASK_TO_UNDO));
        }
        
    }

    private CommandResult undoEdit() {
        try {
            model.editTask(commandHistory.getTask(), commandHistory.getOldTask());
            history.deleteCommandHistory(commandHistory);
            addUndoCommand(commandHistory);
            indicateDisplayListChanged();
            return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, commandHistory.getOldTask()));
        } catch (DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }
        
        assert false: "Undo edit should return a command result";
        return null;
    }
    
    private CommandResult redoEdit() {
        try {
            model.editTask(commandHistory.getOldTask(), commandHistory.getTask());
            history.deleteCommandHistory(commandHistory);
            indicateDisplayListChanged();
            return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, commandHistory.getTask()));
        } catch (DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }
        
        assert false: "Redo edit should return a command result";
        return null;
    }

    private CommandResult undoDelete() {
        try {
            model.addTask(commandHistory.getTask());
            history.deleteCommandHistory(commandHistory);
            addUndoCommand(commandHistory);
            indicateDisplayListChanged();
            return new CommandResult(String.format(MESSAGE_ADD_TASK_SUCCESS, commandHistory.getTask()));
        } catch (DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }
    }

    private CommandResult undoAdd() {
        try {
            model.deleteTask(commandHistory.getTask());
            history.deleteCommandHistory(commandHistory);
            addUndoCommand(commandHistory);
            indicateDisplayListChanged();
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }
        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, commandHistory.getTask()));
    }
    
    private void addUndoCommand(CommandHistory commandHistory) {
        if (commandHistory.isRedoTrue()) {
            return;
        }
        commandHistory.setCommandText("undo " + commandHistory.getCommandText());
        commandHistory.setToRedoToTrue();
        commandHistoryList.add(commandHistory);
    }
    
    /******** static methods *********/
    
    private static int getOffset(int index) {
        return index - 1;
    }

    /****** Event ******/
    public void indicateDisplayListChanged() {
        EventsCenter.getInstance().post(
                new DisplayListChangedEvent(history.getListCommandText()));
    }
}
```
###### \java\seedu\taskell\logic\commands\ViewCalendarCommand.java
``` java
package seedu.taskell.logic.commands;

import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.events.ui.DisplayCalendarViewEvent;

/** Shows calendar view on right panel
 * */
public class ViewCalendarCommand extends Command {
    
    public static final String COMMAND_WORD_1 = "calendar";
    public static final String COMMAND_WORD_2 = "cal";
    
    public static final String MESSAGE_SUCCESS = "Displayed calendar.";

    @Override
    public CommandResult execute() {
        indicateDisplayCalendarView();
        return new CommandResult(String.format(MESSAGE_SUCCESS));
    }
    
    private void indicateDisplayCalendarView() {
        EventsCenter.getInstance().post(new DisplayCalendarViewEvent());
    }

}
```
###### \java\seedu\taskell\logic\commands\ViewHistoryCommand.java
``` java
package seedu.taskell.logic.commands;

import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.events.ui.DisplayListChangedEvent;
import seedu.taskell.history.History;
import seedu.taskell.history.HistoryManager;

/** Lists a list of previous commands available for Undo operation
 * */
public class ViewHistoryCommand extends Command {
    
    public static final String COMMAND_WORD_1 = "history";
    public static final String COMMAND_WORD_2 = "hist";

    public static final String MESSAGE_SUCCESS = "Listed all commands available for undo.";
    
    private static ViewHistoryCommand self;
    private History history;
    
    public ViewHistoryCommand() {
        history = HistoryManager.getInstance();
    }
    
    public static ViewHistoryCommand getInstance() {
        if (self == null) {
            self = new ViewHistoryCommand();
        }
        
        return self;
    }

    @Override
    public CommandResult execute() {
        indicateDisplayListChanged();
        return new CommandResult(MESSAGE_SUCCESS);
    }

    public void indicateDisplayListChanged() {
        EventsCenter.getInstance().post(
                new DisplayListChangedEvent(history.getListCommandText()));
    }

}
```
###### \java\seedu\taskell\logic\parser\Parser.java
``` java
    
    /** if type of command is undoable, saves to history for undoing
     * */
    private void saveToHistory(String userInput, final String commandWord) {
        if (commandWord.equals(AddCommand.COMMAND_WORD) 
                || commandWord.equals(DeleteCommand.COMMAND_WORD)
                || commandWord.contains(UndoCommand.EDIT)) {
            IncorrectCommand.setIsUndoableCommand(true);
            history.addCommand(userInput, commandWord);
        } else {
            IncorrectCommand.setIsUndoableCommand(false);
        }
    }
    
```
###### \java\seedu\taskell\logic\parser\Parser.java
``` java

    /**
     * Parses arguments in the context of undo command.
     * 
     */
    private Command prepareUndo(String args) {
        if (args.isEmpty()) {
            return new UndoCommand();
        }
        
        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoCommand.MESSAGE_USAGE));
        } 
        return new UndoCommand(index.get());
    }

    /**
     * Parses arguments in the context of the find task by tags command.
     * 
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareFindByTag(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindTagCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindTagCommand(keywordSet);

    }

    /**
     * Parses arguments in the context of the save storage location command.
     * 
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareSaveStorageLocation(String args) {
        if (args.isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SaveStorageLocationCommand.MESSAGE_USAGE));
        }
        return new SaveStorageLocationCommand(args);
    }
```
###### \java\seedu\taskell\MainApp.java
``` java
    @Subscribe
    private void handleStorageLocationChangedEvent(StorageLocationChangedEvent event) {
        logger.info("saving storage");
        config = event.getConfig();
        storage.clearTaskManager();
        storage = new StorageManager(config.getTaskManagerFilePath(), config.getUserPrefsFilePath());
        SaveStorageLocationCommand.setStorage(storage);
    }
```
###### \java\seedu\taskell\model\ModelManager.java
``` java
    @Override
    public void updateFilteredTaskListByAnyKeyword(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new TagsQualifier(keywords)));
    }

```
###### \java\seedu\taskell\model\ModelManager.java
``` java
        @Override
        public boolean run(ReadOnlyTask task) {
            String searchString = task.getDescription().description + " " + task.tagsSimpleString();
            return nameKeyWords.stream().allMatch(keyword -> StringUtil.containsIgnoreCase(searchString, keyword));
        }

```
###### \java\seedu\taskell\model\ModelManager.java
``` java
    private class TagsQualifier implements Qualifier {
        private Set<String> tagsKeyWords;

        TagsQualifier(Set<String> keyWords) {
            this.tagsKeyWords = keyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return tagsKeyWords.stream()
                    .filter(keyword -> StringUtil.containsIgnoreCase(task.tagsSimpleString(), keyword)).findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", tagsKeyWords);
        }
    }

```
###### \java\seedu\taskell\storage\JsonConfigStorage.java
``` java
package seedu.taskell.storage;

import java.io.File;
import java.io.IOException;
import java.util.Optional;
import java.util.logging.Logger;

import seedu.taskell.commons.core.Config;
import seedu.taskell.commons.core.LogsCenter;
import seedu.taskell.commons.exceptions.DataConversionException;
import seedu.taskell.commons.util.FileUtil;

/**
 * A class to access Config stored in the hard disk as a json file
 */

public class JsonConfigStorage implements ConfigStorage {

    private static final Logger logger = LogsCenter.getLogger(JsonConfigStorage.class);
    
    private String filePath;
    
    public JsonConfigStorage(String filePath) {
        this.filePath = filePath;
    }
    
    @Override
    public Optional<Config> readConfigFile() throws DataConversionException, IOException {
        return readConfig(filePath);
    }

    @Override
    public void saveConfigFile(Config config) throws IOException {
        saveConfig(config, filePath);
    }
    
    /**
     * Similar to {@link #readConfigFile()}
     * @param configFilePath location of the data. Cannot be null.
     * @throws DataConversionException if the file format is not as expected.
     */
    public Optional<Config> readConfig(String configFilePath) throws DataConversionException {
        assert configFilePath != null;

        File configFile = new File(configFilePath);

        if (!configFile.exists()) {
            logger.info("Config file "  + configFile + " not found");
            return Optional.empty();
        }

        Config config;

        try {
            config = FileUtil.deserializeObjectFromJsonFile(configFile, Config.class);
        } catch (IOException e) {
            logger.warning("Error reading from config file " + configFile + ": " + e);
            throw new DataConversionException(e);
        }

        return Optional.of(config);
    }

    /**
     * Similar to {@link #saveConfigFile(Config)}
     * @param configFilePath location of the data. Cannot be null.
     */
    private void saveConfig(Config config, String configFilePath) throws IOException {
        assert config != null;
        assert configFilePath != null;
        assert !configFilePath.isEmpty();

        FileUtil.serializeObjectToJsonFile(new File(configFilePath), config);
    }

}
```
###### \java\seedu\taskell\ui\CalendarView.java
``` java
package seedu.taskell.ui;

import java.time.LocalDateTime;
import java.util.ArrayList;

import jfxtras.scene.control.agenda.Agenda;
import jfxtras.scene.control.agenda.Agenda.Appointment;
import seedu.taskell.model.Model;
import seedu.taskell.model.ReadOnlyTaskManager;
import seedu.taskell.model.task.ReadOnlyTask;
import seedu.taskell.model.task.Task;
import seedu.taskell.model.task.TaskStatus;
import seedu.taskell.model.task.UniqueTaskList;

/** This class holds the necessary elements to display calendar UI via Agenda API from jfxtras
 * */

public class CalendarView {
    
    private static Model model;
    
    private Agenda agenda;
    
    public CalendarView() {
        agenda = new Agenda();
        setAgendaProperties();
        loadTasks();
    }
    
    public static void setData(Model m) {
        model = m;
    }
    
    public Agenda getAgenda() {
        agenda.appointments().clear();
        loadTasks();
        return agenda;
    }
    
    private void setAgendaProperties() {
        agenda.setAllowDragging(false);
        agenda.setAllowResize(false);
        agenda.setFocusTraversable(false);
        
        agenda.setStyle("-fx-font-size: 12pt");
    }
    
    public void loadTasks() {
        agenda.appointments().clear();
        
        ReadOnlyTaskManager taskManager = model.getTaskManager();
        UniqueTaskList taskList = taskManager.getUniqueTaskList();
        
        ArrayList<Appointment> appointments = new ArrayList<>();
        int i=1;
        
        for (ReadOnlyTask task: taskList) {
            
            if (isValidEventTask(task)) {
                appointments.add(new Agenda.AppointmentImplLocal()
                        .withStartLocalDateTime(task.getStartDate().toLocalDateTime(task.getStartTime()))
                        .withEndLocalDateTime(task.getEndDate().toLocalDateTime(task.getEndTime()))
                        .withSummary(task.getDescription().description)
                        .withAppointmentGroup(
                                new Agenda.AppointmentGroupImpl().withStyleClass("group"+i)));
            }
            
            i++;
        }
        
        agenda.appointments().addAll(appointments);
        
        //"-fx-background-color: #EC407A; -fx-fill: #EC407A;"
    }

    private boolean isValidEventTask(ReadOnlyTask task) {
        return task.getTaskStatus().toString().equals(TaskStatus.INCOMPLETE) 
                && task.getTaskType().equals(Task.EVENT_TASK);
    }

}
```
###### \java\seedu\taskell\ui\DisplayPanel.java
``` java
package seedu.taskell.ui;

import javafx.scene.Node;
import javafx.scene.control.TextArea;
import javafx.scene.layout.AnchorPane;
import jfxtras.scene.control.agenda.Agenda;
import seedu.taskell.commons.core.LogsCenter;
import seedu.taskell.commons.util.FxViewUtil;
import seedu.taskell.logic.commands.AddCommand;
import seedu.taskell.logic.commands.HelpCommand;
import seedu.taskell.logic.commands.ViewCalendarCommand;
import seedu.taskell.logic.commands.ViewHistoryCommand;

import java.util.ArrayList;
import java.util.logging.Logger;

/**
 * The Display Panel of the App, on right side of screen
 * shows history or calendar view
 * calendar view is default view
 */
public class DisplayPanel extends UiPart {

    public static final String MESSAGE_NO_HISTORY = "No commands available for undo.";
    public static final String MESSAGE_DISPLAY_HISTORY = "List of command history available for undo:\n";

    private static final String WELCOME_MESSAGE = "Welcome to Taskell!\n"
            + "Enter '" + AddCommand.COMMAND_WORD + "' in command box to add a task.\n"
            + "Enter '" + ViewHistoryCommand.COMMAND_WORD_1 + "' for a list of commands to undo.\n"
            + "Enter '" + ViewCalendarCommand.COMMAND_WORD_1 + "' to view calendar.\n"
            + "Enter '" + HelpCommand.COMMAND_WORD + "' for more information about commands.";

    private static Logger logger = LogsCenter.getLogger(DisplayPanel.class);
    
    public static final String DISPLAY_PANEL_ID = "displayPanel";
    private static final String STATUS_BAR_STYLE_SHEET = "result-display";
    
    private TextArea displayTextArea;
    private CalendarView calendarView;
    private Agenda agenda;

    /**
     * Constructor is kept private as {@link #load(AnchorPane)} is the only way to create a DisplayPanel.
     */
    private DisplayPanel() {
        calendarView = new CalendarView();
        displayTextArea = new TextArea();
        agenda = calendarView.getAgenda();
    }

    @Override
    public void setNode(Node node) {
        //not applicable
    }

    @Override
    public String getFxmlPath() {
        return null; //not applicable
    }

    /**
     * This method should be called after the FX runtime is initialized and in FX application thread.
     * @param placeholder The AnchorPane where the DisplayPanel must be inserted
     */
    public static DisplayPanel load(AnchorPane placeholder){
        logger.info("Initializing displayTextArea panel");
        DisplayPanel displayPanel = new DisplayPanel();
        
        displayPanel.displayTextArea.setEditable(false);
        displayPanel.displayTextArea.setId(DISPLAY_PANEL_ID);
        displayPanel.displayTextArea.getStyleClass().removeAll();
        displayPanel.displayTextArea.getStyleClass().add(STATUS_BAR_STYLE_SHEET);
        
        FxViewUtil.applyAnchorBoundaryParameters(displayPanel.displayTextArea, 0.0, 0.0, 0.0, 0.0);
        placeholder.getChildren().add(displayPanel.displayTextArea);
        
        displayPanel.displayTextArea.setText(WELCOME_MESSAGE);
       
        return displayPanel;
    }
    
    /** called whenever history list needs to be shown on display panel
     * */
    public void loadList(AnchorPane placeholder, ArrayList<String> list) {
        placeholder.getChildren().clear();
        placeholder.getChildren().add(displayTextArea);
        
        displayTextArea.setText("");
        if (list.isEmpty()) {
            displayTextArea.setText(MESSAGE_NO_HISTORY);
        }
        else {
            displayTextArea.setText(MESSAGE_DISPLAY_HISTORY);
            for (int i=0; i<list.size(); i++) {
                int index = i+1;
                displayTextArea.appendText(index + ". " + list.get(i) + "\n");
            }
        }
    }
    
    /** default view
     *  clears panel if displayTextArea is showing
     *  fills panel with Agenda for events for the week
     * */
    public void loadCalendar(AnchorPane placeholder) {
               
        placeholder.getChildren().remove(displayTextArea);
        
        agenda = calendarView.getAgenda();
        FxViewUtil.applyAnchorBoundaryParameters(agenda, 0.0, 0.0, 0.0, 0.0);
        placeholder.getChildren().add(agenda);
             
    }
    
```
###### \java\seedu\taskell\ui\MainWindow.java
``` java
    
    public void loadList(ArrayList<String> list) {
        displayPanel.loadList(displayPanelPlaceholder, list);
    }
    
    public void loadCalendarView() {
        displayPanel.loadCalendar(displayPanelPlaceholder);
    }
    
```
###### \java\seedu\taskell\ui\UiManager.java
``` java
    
    private Alert showConfirmClearAlertDialogAndWait() {
        return showAlertDialogAndWaitForConfirm(Alert.AlertType.CONFIRMATION, "Clear all tasks?", 
                "Clear all tasks?", "Are you sure you wish to clear all data?");
    }
    
```
###### \java\seedu\taskell\ui\UiManager.java
``` java
    
    @Subscribe
    private void handleDisplayList(DisplayListChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        logger.info("Displaying list...");
        mainWindow.loadList(event.getList());
    }
    
    @Subscribe
    private void handleShowCalendarView(DisplayCalendarViewEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        logger.info("Displaying calendar view...");
        mainWindow.loadCalendarView();
    }
    
    @Subscribe
    private void handleClearCommandInput(ClearCommandInputEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        Alert alert = showConfirmClearAlertDialogAndWait();
        
        if (alert.getResult() == ButtonType.OK) {
            logger.info("clearing");
            ClearCommand.getInstance().executeClear();
        }
    }
    
```
